(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.troika_animation = {}));
}(this, (function (exports) { 'use strict';

  /*
   * Built-in easing functions for use in Troika animations. Any of the easings defined here
   * may be referred to within Tweens by their exported symbol name, or by reference.
   * 
   * The implementations here are roughly based on the logic from the jQuery Easing plugin
   * (original license blocks are maintained below for completeness), but they have been
   * significantly rewritten to use a single 0-1 time argument signature, converted to ES2015
   * syntax, and otherwise modified for succinctness or performance.
   */

  var pow = Math.pow;
  var PI = Math.PI;
  var sqrt = Math.sqrt;
  var HALF_PI = PI / 2;
  var TWO_PI = PI * 2;


  // factories for common easing function patterns
  function makeInOut(inFn, outFn) {
    return function (t) { return t < 0.5 ? inFn(t * 2) * 0.5 : outFn(t * 2 - 1) * 0.5 + 0.5; }
  }
  function makeExpIn(exp) {
    return function (t) { return pow(t, exp); }
  }
  function makeExpOut(exp) {
    return function (t) { return 1 - pow(1 - t, exp); }
  }
  function makeExpInOut(exp) {
    return function (t) { return t < 0.5 ?
      pow(t * 2, exp) * 0.5 :
      (1 - pow(1 - (t * 2 - 1), exp)) * 0.5 + 0.5; }
  }


  var linear = function (t) { return t; };

  var easeInQuad = makeExpIn(2);
  var easeOutQuad = makeExpOut(2);
  var easeInOutQuad = makeExpInOut(2);

  var easeInCubic = makeExpIn(3);
  var easeOutCubic = makeExpOut(3);
  var easeInOutCubic = makeExpInOut(3);

  var easeInQuart = makeExpIn(4);
  var easeOutQuart = makeExpOut(4);
  var easeInOutQuart = makeExpInOut(4);

  var easeInQuint = makeExpIn(5);
  var easeOutQuint = makeExpOut(5);
  var easeInOutQuint = makeExpInOut(5);

  var easeInSine = function (t) { return 1 - Math.cos(t * (HALF_PI)); };
  var easeOutSine = function (t) { return Math.sin(t * (HALF_PI)); };
  var easeInOutSine = function (t) { return -0.5 * (Math.cos(PI * t) - 1); };

  var easeInExpo = function (t) { return (t === 0) ? 0 : pow(2, 10 * (t - 1)); };

  var easeOutExpo = function (t) { return (t === 1) ? 1 : 1 - pow(2, -10 * t); };

  var easeInOutExpo = function (t) { return (t === 0 || t === 1) ? t :
    t < 0.5 ?
      pow(2, 10 * (t * 2 - 1)) * 0.5 :
      (1 - pow(2, -10 * (t * 2 - 1))) * 0.5 + 0.5; };

  var easeInCirc = function (t) { return 1 - sqrt(1 - t * t); };

  var easeOutCirc = function (t) { return sqrt(1 - pow(t - 1, 2)); };

  var easeInOutCirc = makeInOut(easeInCirc, easeOutCirc);

  var easeInElastic = function (t) { return (t === 0 || t === 1) ? t : 1 - easeOutElastic(1 - t); };

  var easeOutElastic = function (t) { return (t === 0 || t === 1) ? t :
      Math.pow(2, -10 * t) * Math.sin((t - 0.075) * TWO_PI / 0.3) + 1; };

  var easeInOutElastic = makeInOut(easeInElastic, easeOutElastic);

  var easeInBack = function (t) { return t * t * (2.70158 * t - 1.70158); };

  var easeOutBack = function (t) { return (t -= 1) * t * (2.70158 * t + 1.70158) + 1; };

  var easeInOutBack = function (t) {
    var s = 1.70158 * 1.525;
    return (t *= 2) < 1 ? 
      0.5 * (t * t * ((s + 1) * t - s)) : 
      0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2)
  };

  var easeInBounce = function (t) { return 1 - easeOutBounce(1 - t); };

  var easeOutBounce = function (t) { return t < (1 / 2.75) ? 
      (7.5625 * t * t) :
    t < (2 / 2.75) ? 
      (7.5625 * (t -= (1.5 / 2.75)) * t + .75) :
    t < (2.5 / 2.75) ? 
      (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) :
      (7.5625 * (t -= (2.625 / 2.75)) * t + .984375); };

  var easeInOutBounce = makeInOut(easeInBounce, easeOutBounce);

  // Aliases...?
  // export {
  //   easeInBack as swingFrom,
  //   easeOutBack as swingTo,
  //   easeInOutBack as swingFromTo,
  //   easeOutBounce as bounce,
  //   easeFrom
  // }





  // ===== License blocks from originating works: =====

  /*
   * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
   *
   * Uses the built in easing capabilities added In jQuery 1.1
   * to offer multiple easing options
   *
   * TERMS OF USE - jQuery Easing
   *
   * Open source under the BSD License.
   *
   * Copyright Â© 2008 George McGinley Smith
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   *
   * Redistributions of source code must retain the above copyright notice, this list of
   * conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, this list
   * of conditions and the following disclaimer in the documentation and/or other materials
   * provided with the distribution.
   *
   * Neither the name of the author nor the names of contributors may be used to endorse
   * or promote products derived from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
   * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
   *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   *
  */

  /*
   *
   * TERMS OF USE - EASING EQUATIONS
   *
   * Open source under the BSD License.
   *
   * Copyright Â© 2001 Robert Penner
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   *
   * Redistributions of source code must retain the above copyright notice, this list of
   * conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, this list
   * of conditions and the following disclaimer in the documentation and/or other materials
   * provided with the distribution.
   *
   * Neither the name of the author nor the names of contributors may be used to endorse
   * or promote products derived from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
   * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
   *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   */

  var Easings = /*#__PURE__*/Object.freeze({
    __proto__: null,
    linear: linear,
    easeInQuad: easeInQuad,
    easeOutQuad: easeOutQuad,
    easeInOutQuad: easeInOutQuad,
    easeInCubic: easeInCubic,
    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint,
    easeInSine: easeInSine,
    easeOutSine: easeOutSine,
    easeInOutSine: easeInOutSine,
    easeInExpo: easeInExpo,
    easeOutExpo: easeOutExpo,
    easeInOutExpo: easeInOutExpo,
    easeInCirc: easeInCirc,
    easeOutCirc: easeOutCirc,
    easeInOutCirc: easeInOutCirc,
    easeInElastic: easeInElastic,
    easeOutElastic: easeOutElastic,
    easeInOutElastic: easeInOutElastic,
    easeInBack: easeInBack,
    easeOutBack: easeOutBack,
    easeInOutBack: easeInOutBack,
    easeInBounce: easeInBounce,
    easeOutBounce: easeOutBounce,
    easeInOutBounce: easeInOutBounce
  });

  /**
   * Simple numeric interpolator function
   */
  function number(fromValue, toValue, progress) {
    return fromValue + (toValue - fromValue) * progress
  }

  /**
   * Interpolator for color values; decomposes the color into r/g/b channels and does
   * numeric interpolation on each individually. The result is a 24-bit integer value
   * holding the r/g/b channels in its 3 bytes.
   */
  function color(fromValue, toValue, progress) {
    fromValue = colorValueToNumber(fromValue);
    toValue = colorValueToNumber(toValue);
    return rgbToNumber(
      number(fromValue >> 16 & 255, toValue >> 16 & 255, progress),
      number(fromValue >> 8 & 255, toValue >> 8 & 255, progress),
      number(fromValue & 255, toValue & 255, progress)
    )
  }



  /**
   * Utility for converting one of the supported color value types to a 24-bit numeric color
   * representation.
   * @param {*} value - The input value to translate. Supported types:
   * - 24-bit number: simply returned as is
   * - string value: evaluated using a canvas context, so supports color keywords, rgb(), hsl(), etc.
   * - a three.js `Color` object
   * @return {*}
   */
  var colorValueToNumber = (function() {
    var colorCanvas, colorCanvasCtx;

    // Cache for evaluated string values
    var stringCache = Object.create(null);
    var stringCacheSize = 0;
    var stringCacheMaxSize = 2048;

    return function(value) {
      if (typeof value === 'number') {
        return value
      }
      else if (typeof value === 'string') {
        if (value in stringCache) {
          return stringCache[value]
        }

        // 2D canvas for evaluating string values
        if (!colorCanvas) {
          colorCanvas = document.createElement('canvas');
          colorCanvasCtx = colorCanvas.getContext('2d');
        }

        colorCanvas.width = colorCanvas.height = 1;
        colorCanvasCtx.fillStyle = value;
        colorCanvasCtx.fillRect(0, 0, 1, 1);
        var colorData = colorCanvasCtx.getImageData(0, 0, 1, 1).data;
        var result = rgbToNumber(colorData[0], colorData[1], colorData[2]);

        // Enforce max cache size - for now this invalidates the entire cache when reaching
        // the max size; we could use a true LRU cache but hitting the max size should be rare
        // in real world usage so this should suffice as a simple memory size protection.
        if (stringCacheSize > stringCacheMaxSize) {
          stringCache = Object.create(null);
          stringCacheSize = 0;
        }

        // Put into cache
        stringCache[value] = result;
        stringCacheSize++;

        return result
      }
      else if (value && value.isColor) {
        return value.getHex()
      }
      else {
        return 0 //fallback to black
      }
    }
  })();

  function rgbToNumber(r, g, b) {
    return r << 16 ^ g << 8 ^ b
  }

  var Interpolators = /*#__PURE__*/Object.freeze({
    __proto__: null,
    number: number,
    color: color
  });

  var linear$1 = function (v) { return v; };
  var maxSafeInteger = 0x1fffffffffffff;

  /**
   * @class Tween
   * Represents a transition between two values across a duration of time.
   *
   * Typically you will create a Tween between two values, with a callback function to handle the intermediate values,
   * and then start the Tween in a {@link Runner} which will start invoking the tween on each animation frame until
   * it reaches the end of its duration.
   *
   * @param callback {Function} a function that will be called with the current tween value at a given point in time.
   * @param fromValue {*} the beginning value
   * @param toValue {*} the ending value
   * @param duration {Number} the duration of the tween in milliseconds
   * @param [delay] {Number} optional time in milliseconds to wait before starting the tween
   * @param [easing] {Function|String} optional easing to be applied to the tween values. Can either be a function
   *        that takes a value from 0 to 1 and returns a corresponding "eased" value, or a string that matches the
   *        name of one of the common Penner easing functions - see http://easings.net/ Defaults to linear easing.
   * @param [iterations] {Number} optional number of times to repeat the tween animation. For endless repeating,
   *        specify `Infinity`.
   * @param [direction] {String} direction to run the tween; one of 'forward', 'reverse', or 'alternate'. For
   *        'alternate', it will toggle between forward and reverse on each iteration.
   * @param [interpolate] {String|Function} how tweened values should be calculated between the fromValue and toValue.
   *        Can be the string name for one of the built-in interpolators in Interpolators.js, or a custom function that
   *        will be passed 3 arguments: `fromValue`, `toValue`, and `progress` from 0 to 1.
   */
  var Tween = function Tween(callback, fromValue, toValue, duration, delay, easing, iterations, direction, interpolate) {
    if ( duration === void 0 ) duration=750;
    if ( delay === void 0 ) delay=0;
    if ( easing === void 0 ) easing=linear$1;
    if ( iterations === void 0 ) iterations=1;
    if ( direction === void 0 ) direction='forward';
    if ( interpolate === void 0 ) interpolate='number';

    this.callback = callback;
    this.fromValue = fromValue;
    this.toValue = toValue;
    this.duration = duration;
    this.delay = delay;
    this.easing = typeof easing === 'string' ? (Easings[easing] || linear$1) : easing;
    this.iterations = iterations;
    this.direction = direction;
    this.interpolate = typeof interpolate === 'function' ? interpolate : Interpolators[interpolate] || number;

    /**
     * @property totalElapsed
     * @type {number}
     * The total duration of this tween from 0 to its completion, taking into account its `duration`, `delay`, and
     * `iterations`. This is calculated once upon instantiation, and may be used to determine whether the tween is
     * finished or not at a given time.
     */
    this.totalElapsed = this.iterations < maxSafeInteger ? this.delay + (this.duration * this.iterations) : maxSafeInteger;
  };

  /**
   * For a given elapsed time relative to the start of the tween, calculates the value at that time and calls the
   * `callback` function with that value. If the given time is during the `delay` period, the callback will not be
   * invoked.
   * @param {number} time
   */
  Tween.prototype.gotoElapsedTime = function gotoElapsedTime (time) {
    var duration = this.duration;
    var delay = this.delay;
    if (time >= delay) {
      time = Math.min(time, this.totalElapsed) - delay; //never go past final value
      var progress = (time % duration) / duration;
      if (progress === 0 && time !== 0) { progress = 1; }
      progress = this.easing(progress);
      if (this.direction === 'reverse' || (this.direction === 'alternate' && Math.ceil(time / duration) % 2 === 0)) {
        progress = 1 - progress;
      }
      this.callback(this.interpolate(this.fromValue, this.toValue, progress));
    }
  };

  /**
   * Like `gotoElapsedTime` but goes to the very end of the tween.
   */
  Tween.prototype.gotoEnd = function gotoEnd () {
    this.gotoElapsedTime(this.totalElapsed);
  };

  /**
   * A specialized Tween that controls one or more other tweens. The controlled tweens are treated as a
   * single unit and the easing/iterations/etc. are applied across the total duration of all tweens.
   */
  var MultiTween = /*@__PURE__*/(function (Tween) {
    function MultiTween(tweens, duration, delay, easing, iterations, direction) {
      if (typeof duration !== 'number') {
        // Calculate duration based on the longest individual total duration
        duration = tweens.reduce(function (dur, tween) { return Math.max(dur, tween.totalElapsed); }, 0);
      }
      if (duration === Infinity) {
        // Make an infinite duration finite, so easing math still works
        duration = Number.MAX_VALUE;
      }

      // Tween the total duration time
      Tween.call(this, null, 0, duration, duration, delay, easing, iterations, direction);
      if (tweens.length === 1) {
        this.callback = tweens[0].gotoElapsedTime.bind(tweens[0]);
      } else {
        tweens.sort(endTimeComparator); //sort by end time to ensure proper iteration in syncTweens
        this.callback = this._syncTweens;
      }
      this.tweens = tweens;
    }

    if ( Tween ) MultiTween.__proto__ = Tween;
    MultiTween.prototype = Object.create( Tween && Tween.prototype );
    MultiTween.prototype.constructor = MultiTween;

    MultiTween.prototype._syncTweens = function _syncTweens (time) {
      // NOTE: forward iteration is important here so the tweens are evaluated in order
      // of when they end; that way later tweens will take precedence over earlier ones.
      // TODO would be nice to ignore tweens past their totalElapsed entirely, but have to
      // figure out how to do that while ensuring they don't get stuck with a value that is
      // slightly prior to their end state.
      for (var i = 0, len = this.tweens.length; i < len; i++) {
        this.tweens[i].gotoElapsedTime(time);
      }
    };

    return MultiTween;
  }(Tween));

  function endTimeComparator(a, b) {
    return a.totalElapsed - b.totalElapsed
  }

  var runners = [];
  var nextFrameTimer = null;
  var hasStoppedRunners = false;

  function noop() {}

  function isRunnerRunning(runner) {return runner.runner$running}
  function isTweenNotStopped(tween) {return !tween.runner$stopped}

  function tick() {
    var now = Date.now();
    nextFrameTimer = null;

    // Filter out any runners that were stopped since last tick
    if (hasStoppedRunners) {
      runners = runners.filter(isRunnerRunning);
      hasStoppedRunners = false;
    }

    if (runners.length) {
      // Sync each runner, filtering out empty ones as we go
      for (var i = runners.length; i-- > 0;) {
        runners[i]._tick(now);
      }
      // Queue next tick if there are still active runners
      queueFrame();
    }
  }

  var _scheduler = window;

  /**
   * Allow the scheduler to be modified, e.g. when switching to an immersive XRSession.
   *
   * TODO: we may want to only do this for a subset of animations, like just those subject to
   *  an XRSession, while letting others use the default. This global hook won't work for that.
   *
   * @param {{requestAnimationFrame, cancelAnimationFrame}} scheduler - an object holding
   *        the two scheduling functions.
   */
  function setAnimationScheduler(scheduler) {
    scheduler = scheduler || window;
    if (scheduler !== _scheduler) {
      if (nextFrameTimer) {
        _scheduler.cancelAnimationFrame(nextFrameTimer);
        nextFrameTimer = null;
      }
      _scheduler = scheduler;
      queueFrame();
    }
  }

  function queueFrame() {
    if (!nextFrameTimer) {
      nextFrameTimer = _scheduler.requestAnimationFrame(tick);
    }
  }


  function startRunner(runner) {
    if (!runner.runner$running) {
      runner.runner$running = true;
      runners.push(runner);
      queueFrame();
    }
  }

  function stopRunner(runner) {
    runner.runner$running = false;
    hasStoppedRunners = true;
  }


  /**
   * @class Runner
   * A container for {@link Tween} instances that handles invoking them on each animation frame.
   */
  var Runner = function Runner() {
    this.tweens = [];
  };

  Runner.prototype.destructor = function destructor () {
    this.tweens = null;
    stopRunner(this);
    this.start = this.stop = this.pause = this._tick = noop;
  };

  /**
   * Add a tween to the runner. It will be invoked on the next frame, not immediately.
   * @param {Tween} tween
   */
  Runner.prototype.start = function start (tween) {
    // If previously paused, update start time to account for the duration of the pause
    if (tween.runner$paused && tween.runner$started) {
      tween.runner$started += (Date.now() - tween.runner$paused);
    } else {
      this.tweens.push(tween);
    }
    tween.runner$paused = null;
    tween.runner$stopped = false;

    // add runner to running runners
    startRunner(this);
  };

  /**
   * Remove a tween from the runner.
   * @param tween
   */
  Runner.prototype.stop = function stop (tween) {
    // queue tween for removal from list on next tick
    tween.runner$stopped = true;
    tween.runner$paused = null;
  };

  /**
   * Pause a tween; call `runner.start(tween)` to unpause it
   * @param tween
   */
  Runner.prototype.pause = function pause (tween) {
    if (!tween.runner$paused) {
      tween.runner$paused = Date.now();
    }
  };

  /**
   * Stop all running tweens.
   */
  Runner.prototype.stopAll = function stopAll () {
    if (this.tweens) {
      this.tweens.forEach(this.stop, this);
    }
  };

  Runner.prototype._tick = function _tick (now) {
    var tweens = this.tweens;
    var hasStoppedTweens = false;
    var hasRunningTweens = false;

    // Sync each tween, filtering out old finished ones as we go
    for (var i = 0, len = tweens.length; i < len; i++) {
      var tween = tweens[i];
      if (!tween.runner$stopped && !tween.runner$paused) {
        // Sync the tween to current time
        var elapsed = now - (tween.runner$started || (tween.runner$started = now));
        tween.gotoElapsedTime(elapsed);
        hasRunningTweens = true;

        // Queue for removal if we're past its end time
        if (elapsed > tween.totalElapsed) {
          this.stop(tween);
          if (tween.onDone) {
            tween.onDone();
          }
        }
      }
      if (tween.runner$stopped) {
        hasStoppedTweens = true;
      }
    }

    if (hasRunningTweens) {
      this.onTick();
    }

    // Prune list if needed
    // TODO perhaps batch this up so it happens less often
    if (hasStoppedTweens) {
      this.tweens = tweens.filter(isTweenNotStopped);

      // remove runner from running runners if it has no tweens left
      if (!this.tweens.length) {
        stopRunner(this);
        if (this.onDone) {
          this.onDone();
        }
      }
    }
  };

  /**
   * Override to specify a function that will be called at the end of every frame, after all
   * tweens have been updated.
   */
  Runner.prototype.onTick = function onTick () {
    // abstract
  };

  /**
   * Override to specify a function that will be called after all running tweens have completed.
   */
  Runner.prototype.onDone = function onDone () {
    // abstract
  };

  exports.Easings = Easings;
  exports.Interpolators = Interpolators;
  exports.MultiTween = MultiTween;
  exports.Runner = Runner;
  exports.Tween = Tween;
  exports.setAnimationScheduler = setAnimationScheduler;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
