(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('troika-animation'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'troika-animation', 'react', 'prop-types'], factory) :
  (global = global || self, factory(global.troika_core = {}, global.troika_animation, global.React, global.PropTypes));
}(this, (function (exports, troikaAnimation, React, T) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;
  T = T && Object.prototype.hasOwnProperty.call(T, 'default') ? T['default'] : T;

  ///// Miscellaneous Utility Functions /////


  /**
   * Pseudo-polyfilled shortcut for `Object.assign`. Copies own properties from
   * second-and-after arguments onto the first object, overwriting any that already
   * exist, and returns the first argument.
   * @return {object}
   */
  var assign = Object.assign || _assign;

  // Non-native impl; exported for access by tests
  function _assign(/*target, ...sources*/) {
    var arguments$1 = arguments;

    var target = arguments[0];
    for (var i = 1, len = arguments.length; i < len; i++) {
      var source = arguments$1[i];
      if (source) {
        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            target[prop] = source[prop];
          }
        }
      }
    }
    return target
  }


  /**
   * Like {@link assign}, but will ony copy properties that do _not_ already
   * exist on the target object.
   * @return {object}
   */
  function assignIf(/*target, ...sources*/) {
    var arguments$1 = arguments;

    var target = arguments[0];
    for (var i = 1, len = arguments.length; i < len; i++) {
      var source = arguments$1[i];
      if (source) {
        for (var prop in source) {
          if (source.hasOwnProperty(prop) && !target.hasOwnProperty(prop)) {
            target[prop] = source[prop];
          }
        }
      }
    }
    return target
  }

  /**
   * Like {@link assign}, but for any property where the source and target are both
   * sub-objects, does a deep recursive copy.
   * @param {object} target
   * @param {object} source
   */
  function assignDeep(target, source) {
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          if (target[prop] && typeof target[prop] === 'object' && typeof source[prop] === 'object') {
            assignDeep(target[prop], source[prop]);
          } else {
            target[prop] = source[prop];
          }
        }
      }
    }
  }


  /**
   * Iterate over an object's own (non-prototype-inherited) properties
   * @param {object} object - The object to iterate over
   * @param {function} fn - A function that will be invoked for each iterated property. It
   *        will be passed three arguments:
   *        - value (the property value)
   *        - key (the property name)
   *        - object (the object being iterated over)
   * @param {*} [scope] - An optional object to be used as `this` when calling the `fn`
   */
  function forOwn(object, fn, scope) {
    for (var prop in object) {
      if (object.hasOwnProperty(prop)) {
        fn.call(scope, object[prop], prop, object);
      }
    }
  }


  /**
   * Given an object instance, return a consistent unique id for it.
   * @type function
   * @param {Object} obj - The object instance
   * @return {string} id
   */
  var getIdForObject = (function () {
    var objIds = new WeakMap();
    var lastId = 0;
    return function getIdForObject(obj) {
      var id = objIds.get(obj);
      if (!id) {
        objIds.set(obj, (id = "$id" + (++lastId)));
      }
      return id
    }
  })();


  /**
   * Create a function that memoizes the result of another function based on the most
   * recent call's arguments and `this`. The arguments are compared using strict shallow equality.
   * @param {function} fn
   * @return {function}
   */
  function memoize(fn) {
    var prevArgs, prevThis, prevResult;
    return function() {
      var arguments$1 = arguments;

      var changed = !prevArgs || this !== prevThis || arguments.length !== prevArgs.length;
      if (!changed) {
        for (var i = 0, len = arguments.length; i < len; i++) {
          if (arguments$1[i] !== prevArgs[i]) {
            changed = true;
            break
          }
        }
      }
      if (changed) {
        prevArgs = Array.prototype.slice.call(arguments);
        prevThis = this;
        prevResult = fn.apply(this, arguments);
      }
      return prevResult
    }
  }


  /**
   * Utility for the "extend-as" pattern used in several places to decorate facade
   * classes with extra capabilities.
   * @param {string} name - unique identifier for this class extension
   * @param {function} doExtend - the function that creates the actual class extension,
   *        this is passed the base class and will only be called once per base class.
   * @return {function(class): class}
   */
  function createClassExtender(name, doExtend) {
    var cache = new WeakMap();
    return function(classToExtend) {
      var extended = cache.get(classToExtend);
      if (!extended) { //bidir check due to inheritance of statics
        extended = doExtend(classToExtend);
        cache.set(classToExtend, extended);
      }
      return extended
    }
  }


  /**
   * Determine whether a given object is a React element descriptor object, i.e. the
   * result of a JSX transpilation to React.createElement().
   * @param obj
   * @return {boolean}
   */
  function isReactElement(obj) {
    var t = obj.$$typeof;
    return (t && t.toString && t.toString() === 'Symbol(react.element)') || false
  }

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    assign: assign,
    _assign: _assign,
    assignIf: assignIf,
    assignDeep: assignDeep,
    forOwn: forOwn,
    getIdForObject: getIdForObject,
    memoize: memoize,
    createClassExtender: createClassExtender,
    isReactElement: isReactElement
  });

  /**
   * The base class for all Facade classes.
   *
   * A Facade is basically just a class that receives property assignments from a scene descriptor
   * and manages forwarding the resulting state to more complex underlying implementation
   * objects, e.g. ThreeJS objects.
   *
   * The instantiated facade objects have a very simple lifecycle:
   *   - The `constructor` in which the initial state and the underyling implementation object(s)
   *     can be initialized. It will be passed a single argument: the `parent` facade object.
   *   - Updates to the object's properties, usually by direct assignment from the scene descriptor.
   *     These updates can be handled immediately by defining property setters that handle syncing
   *     new values to the underyling implementation object(s).
   *   - The `afterUpdate()` method which signals the end of all property updates; this can be
   *     implemented to handle syncing the full set of updated properties to the underlying
   *     implementation object(s). Useful if an aspect of the syncing relies on multiple properties
   *     or needs things to be synced in a specific order.
   *   - The `destructor` method which is always called when the object is removed from the scene.
   *     Implement this to remove and clean up the underlying implementation object(s) and other
   *     cleanup logic.
   *
   * Scene Descriptors:
   *
   * All facade instances are created, updated, and destroyed based on the current structure of
   * a scene descriptor object. The properties in the descriptor are generally just copied
   * directly to properties of the same names on the facade instance, which can handle them
   * either by custom setters or in `afterUpdate`. There are a few special properties in the
   * descriptor:
   *
   *   - `facade`: (required) a reference to the Facade class that will be instantiated.
   *   - `key`: (recommended) an identifier that is unique amongst the descriptor's siblings, which
   *     is used to associate the descriptor with its corresponding Facade instance. One will be
   *     assigned automatically if omitted, but it's recommended that you set one manually to ensure
   *     descriptors are predictably resolved to the same facade instances when siblings are being
   *     added or removed. Not doing so can lead to unnecessary facade destruction/creation and/or
   *     unpredictable facade states.
   *   - `children`: (optional) for `Parent` facade subclasses, defines the child object descriptors.
   *   - `ref`: (optional) a function that will be called with a reference to the instantiated Facade
   *     on creation, and with `null` on destruction, allowing external code to maintain references
   *     to individual facades.
   *   - `transition`: (optional) defines a set of properties that should be transitioned smoothly
   *     when their value changes. See `Animatable` for more details.
   *   - `animation`: (optional) defines one or more keyframe animations. See `Animatable` for more
   *     details.
   *   - `exitAnimation`: (optional) defines a keyframe animation to run when the facade is removed
   *     from its parent.
   *   - `pointerStates`: (optional) defines sets of property values that should be used in place
   *     of those defined on the main object, when the user's pointer (mouse, touch, vr controller,
   *     etc.) is in `hover` or `active` interaction state with the facade. See `PointerStates`
   *     for more details.
   *
   * It is also possible to define facade descriptors using JSX (https://reactjs.org/docs/introducing-jsx.html),
   * if it is precompiled to `React.createElement` calls. In this case, use the facade class as the JSX
   * element name instead of a `facade` property, and child descriptors are defined as nested JSX elements i
   * nstead of a `children` property. *NOTE:* While this is often a nicer looking syntax than the plain JS object
   * form, be aware that the creation of JSX elements does carry a slight performance cost from extra logic
   * and object allocations, so you should avoid it when defining large numbers of facades or when updating
   * descriptors on every frame.
   */
  var Facade = function Facade(parent) {
    this.$facadeId = "facade" + (idCounter++);
    this.parent = parent;
  };

  /**
   * Performs a manual update of this facade, invoking the afterUpdate lifecycle method and triggering a
   * render. This can be called in event handlers, for example, to affect changes to this facade and its
   * subtree. This process is synchronous. Never override this method as a way to react to updates, as it
   * is not the only way a component is updated; instead override `afterUpdate` or use setters.
   * @param {object} props - A set of properties to be copied to the facade
   */
  Facade.prototype.update = function update (props) {
    if (props && typeof props === 'object') {
      assign(this, props);
      this.afterUpdate();
      this.notifyWorld('needsRender');
    }
  };

  /**
   * Called at the end of an update batch, after all individual properties have been assigned.
   */
  Facade.prototype.afterUpdate = function afterUpdate () {
    // Handle calling ref function
    var ref = this.ref;
    if (ref !== this._lastRef) {
      if (typeof this._lastRef === 'function') {
        this._lastRef.call(null, null);
      }
      if (typeof ref === 'function') {
        ref.call(null, this);
        this._lastRef = ref;
      } else {
        this._lastRef = null;
      }
    }
  };

  /**
   * Dispatch a message with optional data up the facade parent tree.
   */
  Facade.prototype.notifyWorld = function notifyWorld (message, data) {
    if (this.parent) {
      this.parent.onNotifyWorld(this, message, data);
    }
  };

  /**
   * Default onNotifyWorld handler just bubbles it up the parent chain.
   */
  Facade.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
    var notifiableParent = this._notifiableParent;
    if (notifiableParent) {
      notifiableParent.onNotifyWorld.call(notifiableParent, source, message, data);
    } else {
      // Optimization: on first call, walk up the tree looking for the first ancestor with a
      // non-default onNotifyWorld implementation, and save a pointer to that ancestor
      // facade so we can just call it directly the next time without any tree walking.
      notifiableParent = this.parent;
      var defaultImpl = Facade.prototype.onNotifyWorld;
      while (notifiableParent) {
        if (notifiableParent.onNotifyWorld !== defaultImpl) {
          this._notifiableParent = notifiableParent;
          notifiableParent.onNotifyWorld(source, message, data);
          break
        }
        notifiableParent = notifiableParent.parent;
      }
    }
  };

  Facade.prototype.traverse = function traverse (fn) {
    fn(this);
  };

  Facade.prototype.forEachChild = function forEachChild (fn) {
  };

  /**
   * Add an event listener for the given event type.
   * @param {String} type
   * @param {Function} handler
   */
  Facade.prototype.addEventListener = function addEventListener (type, handler) {
    this.notifyWorld('addEventListener', {type: type, handler: handler});
  };

  /**
   * Remove an event listener for the given event type.
   * @param {String} type
   * @param {Function} handler
   */
  Facade.prototype.removeEventListener = function removeEventListener (type, handler) {
    this.notifyWorld('removeEventListener', {type: type, handler: handler});
  };

  /**
   * Dispatch an Event object on this facade, with DOM events bubbling logic.
   * @param {Event} event
   */
  Facade.prototype.dispatchEvent = function dispatchEvent (event) {
    this.notifyWorld('dispatchEvent', event);
  };

  /**
   * Called when the instance is being removed from the scene. Override this to implement any
   * custom cleanup logic.
   */
  Facade.prototype.destructor = function destructor () {
    // Unregister all event listeners from the world
    if (this.parent) {
      this.notifyWorld('removeAllEventListeners');
    }

    // Teardown refs
    if (typeof this.ref === 'function') {
      this.ref.call(null, null);
    }
    this.parent = this._notifiableParent = null;
  };

  assign(Facade.prototype, {
    ref: null,
    _lastRef: null,
    _notifiableParent: null
  });


  var idCounter = 0;
  var DEF_SPECIAL_PROPS = {key:1, facade:1, transition:1, animation:1};

  /**
   * @static
   * Determine if a certain property name is one of the special descriptor properties
   */
  Facade.isSpecialDescriptorProperty = function(name) {
    return DEF_SPECIAL_PROPS.hasOwnProperty(name)
  };

  /**
   * @static
   * Define a property name as an event handler for a given Facade class, so that it
   * automatically updates the global event registry when set.
   * @param {class} facadeClass - the class whose prototype the property should be defined on
   * @param {String} propName - the name of the event handler property, e.g. 'onMouseOver'
   * @param {String} eventType - the type of the event that will trigger the handler, e.g. 'mouseover'
   */
  Facade.defineEventProperty = function(facadeClass, propName, eventType) {
    var privateProp = propName + "➤handler";
    Object.defineProperty(facadeClass.prototype, propName, {
      get: function get() {
        return this[privateProp]
      },
      set: function set(handler) {
        var oldHandler = this[privateProp];
        if ((handler || null) !== (oldHandler || null)) {
          // Remove old listener
          if (typeof oldHandler === 'function') {
            this.removeEventListener(eventType, oldHandler);
          }
          // Add new listener
          if (typeof handler === 'function') {
            this.addEventListener(eventType, handler);
          }
          this[privateProp] = handler;
        }
      }
    });
  };

  var DEFAULT_DURATION = 750;
  var DEFAULT_EASING = 'easeOutCubic';

  var TEMP_ARRAY = [null];

  function animationIdJsonReplacer(key, value) {
    return key === 'paused' ? undefined : value === Infinity ? 'Infinity' : value
  }

  function compareByTime(a, b) {
    return a.time - b.time
  }

  var extendAsAnimatable = createClassExtender('animatable', function(BaseFacadeClass) {
    var AnimatableFacade = /*@__PURE__*/(function (BaseFacadeClass) {
      function AnimatableFacade() {
        var this$1 = this;
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        BaseFacadeClass.apply(this, args);

        // Create root runner for all this object's animation and transition tweens
        this.animation$runner = new troikaAnimation.Runner();
        this.animation$runner.onTick = function () {
          this$1.afterUpdate();
          this$1.notifyWorld('needsRender');
        };
      }

      if ( BaseFacadeClass ) AnimatableFacade.__proto__ = BaseFacadeClass;
      AnimatableFacade.prototype = Object.create( BaseFacadeClass && BaseFacadeClass.prototype );
      AnimatableFacade.prototype.constructor = AnimatableFacade;

      var prototypeAccessors = { transition: { configurable: true },animation: { configurable: true } };

      /**
       * Handle the special "transition" property. The descriptor should be an object with
       * transitionable property names as keys and transition parameters as values. The
       * transition parameters can either be `true` for a default transition, or an object
       * of the form:
       *
       *   transition: {
       *     width: true, //uses default parameters
       *     height: {
       *       duration: n, //in ms, defaults to 750
       *       easing: e, //easing function, defaults to 'easeOutCubic'
       *       delay: n, //in ms, defaults to 0
       *       interpolate: 'number' //one of the named functions in Interpolators.js ('number', 'color', etc.) or a custom Function
       *     }
       *   }
       */
      prototypeAccessors.transition.set = function (descriptor) {
        if (descriptor) {
          // Ensure setter/getter has been created for all props in transition
          for (var propName in descriptor) {
            if (descriptor.hasOwnProperty(propName)) {
              defineTransitionPropInterceptor(propName, this);
            }
          }
        }
        this.transition$descriptor = descriptor;
      };
      prototypeAccessors.transition.get = function () {
        return this.transition$descriptor
      };


      /**
       * Handle the special "animation" property. The descriptor should be an object or array
       * of objects defining a set of keyframes and their playback parameters. Keyframes are
       * defined by numeric keys from 0 to 100, each defining an object with the target
       * property values for that keyframe.
       *
       *   animation: [{
       *     0: {rotateZ: 0, color: 0x000000}, //can also use key "from"
       *     100: {rotateZ: Math.PI * 2, color: 0xffffff}, //can also use key "to"
       *     delay: 0, //starting delay in ms
       *     duration: 2000, //total anim duration in ms, defaults to 750
       *     easing: 'linear', //easing for the whole animation, defaults to 'linear'
       *     iterations: 5, //number of times to loop the animation, defaults to 1. Set to Infinity for endless loop.
       *     direction: 'forward', //either 'forward', 'backward', or 'alternate'
       *     interpolate: {color: 'color'}, //mapping of property names to Interpolators.js names or custom functions
       *     paused: false //if true the animation will be paused at its current position until set back to false
       *   }, ...]
       *
       * Internally the animations will be built into a set of nested tweens:
       *
       * |--------------------------- Main MultiTween ------------------------------------|
       *
       * |------------- Anim 1 MultiTween w/ easing+repeat ----------------|
       * |--- prop1 tween 1 ---|--- prop1 tween 2 ---|--- prop1 tween 3 ---|
       * |--------- prop2 tween 1 --------|--------- prop2 tween 2 --------|
       *
       *                    delay -->|-------- Anim 2 MultiTween w/ easing+repeat --------|
       *                             |----- prop3 tween 1 -----|----- prop3 tween 2 ------|
       *                             |------------------- prop4 tween --------------------|
       *                                            |----------- prop5 tween -------------|
       */
      prototypeAccessors.animation.set = function (descriptor) {
        if (this.animation$descriptor === descriptor) { return }
        this.animation$descriptor = descriptor;
        var oldAnimTweens = this.animation$tweens || null;
        var newAnimTweens = this.animation$tweens = descriptor ? Object.create(null) : null;
        var runner = this.animation$runner;
        var hasChanged = false;

        // Handle single object not wrapped in array
        if (descriptor && !Array.isArray(descriptor)) {
          TEMP_ARRAY[0] = descriptor;
          descriptor = TEMP_ARRAY;
        }

        if (descriptor) {
          for (var i = 0, len = descriptor.length; i < len; i++) {
            var animDesc = descriptor[i];
            if (!animDesc) { continue }

            // Calculate an identifier for this animation based on properties whose modification requires a new tween
            var animId = JSON.stringify(animDesc, animationIdJsonReplacer);
            //console.log(`${animId} - is ${oldAnimTweens && oldAnimTweens[animId] ? '' : 'not'} in old tweens`)

            // If a matching tween already exists, update it
            if (oldAnimTweens && (animId in oldAnimTweens)) {
              var tween = oldAnimTweens[animId];
              if (animDesc.paused) {
                runner.pause(tween);
              } else {
                runner.start(tween);
              }
              newAnimTweens[animId] = tween;
            }
            // Otherwise create a new tween
            else {
              var delay = 0;
              var duration = DEFAULT_DURATION;
              var easing = 'linear';
              var iterations = 1;
              var keyframes = [];
              var direction = 'forward';

              for (var key in animDesc) {
                if (animDesc.hasOwnProperty(key)) {
                  switch(key) {
                    case 'duration':
                      duration = animDesc[key]; break
                    case 'delay':
                      delay = animDesc[key]; break
                    case 'easing':
                      easing = animDesc[key]; break
                    case 'iterations':
                      iterations = animDesc[key]; break
                    case 'direction':
                      direction = animDesc[key]; break
                    default:
                      var percent = key === 'from' ? 0 : key === 'to' ? 100 : parseFloat(key);
                      if (!isNaN(percent) && percent >= 0 && percent <= 100) {
                        keyframes.push({time: percent / 100, props: animDesc[key]});
                        for (var animProp in animDesc[key]) {
                          if (animDesc[key].hasOwnProperty(animProp)) {
                            // Ensure setter is in place
                            defineTransitionPropInterceptor(animProp, this);
                            // Stop any active transition tweens for this property
                            var tweenKey = animProp + '➤anim:tween';
                            if (this[tweenKey]) {
                              runner.stop(this[tweenKey]);
                              this[tweenKey] = null;
                            }
                          }
                        }
                      }
                  }
                }
              }

              if (keyframes.length) {
                // Sort the keyframes by time
                keyframes.sort(compareByTime);
                if (keyframes[0].time > 0) {
                  keyframes.unshift(assignIf({time: 0}, keyframes[0]));
                }

                // Build a MultiTween with tweens for each keyframe+property
                var keyframePropTweens = [];
                for (var j = 1, len$1 = keyframes.length; j < len$1; j++) {
                  var keyframe = keyframes[j];
                  var props = keyframe.props;
                  for (var prop in props) {
                    if (props.hasOwnProperty(prop)) {
                      var prevKeyframe = null;
                      for (var k = j; k--;) {
                        if (prop in keyframes[k].props) {
                          prevKeyframe = keyframes[k];
                          break
                        }
                      }
                      if (prevKeyframe) {
                        var propTween = new troikaAnimation.Tween(
                          this[prop + '➤anim:actuallySet'].bind(this), //callback
                          prevKeyframe.props[prop], //fromValue
                          props[prop], //toValue
                          (keyframe.time - prevKeyframe.time) * duration, //duration
                          prevKeyframe.time * duration, //delay
                          'linear', //easing
                          1, //iterations
                          'forward', //direction
                          animDesc.interpolate && animDesc.interpolate[prop] || 'number'
                        );
                        propTween.$$property = prop;
                        keyframePropTweens.push(propTween);
                      }
                    }
                  }
                }
                var tween$1 = newAnimTweens[animId] = new troikaAnimation.MultiTween(keyframePropTweens, duration, delay, easing, iterations, direction);
                if (!animDesc.paused) {
                  runner.start(tween$1);
                }

                // The tween runner won't do anything until next tick, so immediately sync to the first frame's
                // properties if the animation has no delay to avoid a flash of bad initial state
                if (delay === 0) {
                  var firstKeyframeProps = keyframes[0].props;
                  for (var prop$1 in firstKeyframeProps) {
                    if (firstKeyframeProps.hasOwnProperty(prop$1)) {
                      this[prop$1 + '➤anim:actuallySet'](firstKeyframeProps[prop$1]);
                    }
                  }
                }
              }

              hasChanged = true;
            }
          }
        }

        // Stop any obsolete tweens
        if (oldAnimTweens) {
          for (var animId$1 in oldAnimTweens) {
            if (!newAnimTweens || !newAnimTweens[animId$1]) {
              var tween$2 = oldAnimTweens[animId$1];
              tween$2.gotoEnd(); //force to end value so it doesn't stick partway through
              runner.stop(tween$2);
              hasChanged = true;
            }
          }
        }

        // If the total set of animations has changed, recalc the set of animating properties
        if (hasChanged) {
          if (newAnimTweens) {
            var animatingProps = this.animation$animatingProps = Object.create(null);
            for (var animId$2 in newAnimTweens) {
              var propTweens = newAnimTweens[animId$2].tweens;
              for (var i$1 = propTweens.length; i$1--;) {
                animatingProps[propTweens[i$1].$$property] = true;
              }
            }
          } else {
            this.animation$animatingProps = null;
          }
        }
      };
      prototypeAccessors.animation.get = function () {
        return this.animation$descriptor
      };

      AnimatableFacade.prototype.destructor = function destructor () {
        var this$1 = this;

        var runner = this.animation$runner;
        if (this.exitAnimation && !this.parent.isDestroying) {
          runner.stopAll();
          this.animation = this.exitAnimation;
          this.exitAnimation = this.transition = null;
          var onTick = runner.onTick;
          runner.onTick = function () {
            if (this$1.parent && !this$1.parent.isDestroying) {
              onTick();
            } else {
              // An ancestor may have been destroyed during our exit animation, orphaning this object;
              // catch this case and short-circuit the animation to prevent errors in subsequent ticks
              runner.onDone = null;
              this$1.destructor();
            }
          };
          runner.onDone = function () {
            this$1.notifyWorld('needsRender');
            this$1.destructor();
          };
        } else {
          runner.destructor();
          BaseFacadeClass.prototype.destructor.call(this);
        }
      };

      Object.defineProperties( AnimatableFacade.prototype, prototypeAccessors );

      return AnimatableFacade;
    }(BaseFacadeClass));

    // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it
    // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with
    // other custom setters anywhere else in the prototype chain.
    function defineTransitionPropInterceptor(propName, currentInstance) {
      if (!AnimatableFacade.prototype.hasOwnProperty(propName)) {
        var actualValueKey = propName + "➤anim:actualValue";
        var actuallySetKey = propName + "➤anim:actuallySet";
        var hasBeenSetKey = propName + "➤anim:hasBeenSet";
        var activeTweenKey = propName + "➤anim:tween";

        // Find the nearest getter/setter up the prototype chain, if one exists. Assuming the prototype won't change after the fact.
        var superGetter, superSetter;
        var proto = BaseFacadeClass.prototype;
        while (proto) {
          var desc = Object.getOwnPropertyDescriptor(proto, propName);
          if (desc) {
            superSetter = desc.set;
            superGetter = desc.get;
            if (superSetter && !superGetter || superGetter && !superSetter) {
              throw new Error(("Animatable: property " + propName + " has a custom " + (superSetter ? 'setter' : 'getter') + " but no " + (superSetter ? 'getter' : 'setter') + ". Animatable properties must have both."))
            }
            break
          }
          proto = Object.getPrototypeOf(proto);
        }

        // Function to set the value, bypassing the interceptor setter.
        // Use the super setter if available, otherwise store in a private-ish key
        var actuallySet = superSetter ? function actuallySet(value) {
          superSetter.call(this, value);
          if (!this[hasBeenSetKey]) {
            this[hasBeenSetKey] = true;
          }
        } : function actuallySet(value) {
          this[actualValueKey] = value;
          if (!this[hasBeenSetKey]) {
            this[hasBeenSetKey] = true;
          }
        };
        Object.defineProperty(AnimatableFacade.prototype, actuallySetKey, { value: actuallySet });


        // Add the custom getter/setter for this property
        Object.defineProperty(AnimatableFacade.prototype, propName, {
          get: function get() {
            // Always return the current actual value
            return superGetter ? superGetter.call(this) : this[hasBeenSetKey] ? this[actualValueKey] : BaseFacadeClass.prototype[propName]
          },

          set: function set(value) {
            // Will this value be controlled by an animation? Ignore it since animations take precedence.
            if (this.animation$animatingProps && this.animation$animatingProps[propName]) {
              return
            }

            // Does this value have a transition defined, and are the old/new values transitionable?
            var runner = this.animation$runner;
            var transition = this.transition;
            if (transition && transition[propName] && this[hasBeenSetKey] && transition.hasOwnProperty(propName)) {
              transition = transition[propName];
              // If there's no active transition tween, or the new value is different than the active tween's
              // target value, initiate a new transition tween. Otherwise ignore it.
              var tween$1 = this[activeTweenKey];
              var needsNewTween = false;
              if (tween$1) {
                // Active tween - start new one if new value is different than the old tween's target value
                if (value !== tween$1.toValue) {
                  runner.stop(tween$1);
                  needsNewTween = true;
                }
              } else if (value !== this[propName]) {
                // No active tween - only start one if the value is changing
                needsNewTween = true;
              }
              if (needsNewTween) {
                tween$1 = this[activeTweenKey] = new troikaAnimation.Tween(
                  actuallySet.bind(this), //callback
                  this[propName], //fromValue
                  value, //toValue
                  transition.duration || DEFAULT_DURATION, //duration
                  transition.delay || 0, //delay
                  transition.easing || DEFAULT_EASING, //easing
                  1, //iterations
                  'forward', //direction
                  transition.interpolate || 'number' //interpolate
                );
                runner.start(tween$1);
              }
              return
            }

            // No animation or transition will be started; set the value.
            actuallySet.call(this, value);

            // Clean up obsolete stuff
            var tween = this[activeTweenKey];
            if (tween) { runner.stop(tween); }
            this[activeTweenKey] = null;
          }
        });
      }


      // If the instance had this property set before the intercepting setter was added to the
      // prototype, that would continue to take precedence, so move its value to the private property.
      if (currentInstance.hasOwnProperty(propName)) {
        currentInstance[(propName + "➤anim:actualValue")] = currentInstance[propName];
        currentInstance[(propName + "➤anim:hasBeenSet")] = true;
        delete currentInstance[propName];
      }

    }

    return AnimatableFacade
  });

  /**
   * Allows a facade to be configured with an optional `pointerStates` property, which defines
   * sets of property values that should be used in place of the object's actual values when
   * the user interacts with the facade using their pointer device (mouse, touch, vr controller, etc.)
   * This is not used directly, but is automatically wrapped by `ParentFacade` and `ListFacade` when
   * setting up their children if the `pointerStates` property is present.
   *
   * The `pointerStates` property should point to an object with `hover` and/or `active` properties,
   * each of which is an object holding the individual properties to be used in those states. Any
   * properties defined in `active` will take precedence over those defined in `hover`.
   *
   * The properties will honor any `transition`s defined for them, but the `transition` must be
   * defined on the facade's main configuration object, not within the pointerStates themselves.
   */
  var extendAsPointerStatesAware = createClassExtender('pointerStates', function(BaseFacadeClass) {
    var isHoveringProp = '➤pntr:isHovering';
    var isActiveProp = '➤pntr:isActive';
    var propsWithInterceptors = Object.create(null);

    var PointerStatesAware = /*@__PURE__*/(function (BaseFacadeClass) {
      function PointerStatesAware(parent) {
        BaseFacadeClass.call(this, parent);
        this.addEventListener('mouseover', hoverOverHandler);
        this.addEventListener('mouseout', hoverOutHandler);
        this.addEventListener('mousedown', activeDownHandler);
        this.addEventListener('mouseup', activeUpHandler);
      }

      if ( BaseFacadeClass ) PointerStatesAware.__proto__ = BaseFacadeClass;
      PointerStatesAware.prototype = Object.create( BaseFacadeClass && BaseFacadeClass.prototype );
      PointerStatesAware.prototype.constructor = PointerStatesAware;

      PointerStatesAware.prototype.afterUpdate = function afterUpdate () {
        this._applyPointerStates();
        BaseFacadeClass.prototype.afterUpdate.call(this);
      };

      PointerStatesAware.prototype._applyPointerStates = function _applyPointerStates () {
        var pointerStates = this.pointerStates;
        var hoverValuesToUse = (pointerStates && this[isHoveringProp] && pointerStates.hover) || null;
        var activeValuesToUse = (pointerStates && this[isActiveProp] && pointerStates.active) || null;

        var lastAppliedValues = this['➤pntr:lastAppliedValues'] || propsWithInterceptors;
        var appliedValues = this['➤pntr:lastAppliedValues'] =
          (hoverValuesToUse || activeValuesToUse) ? assign(Object.create(null), hoverValuesToUse, activeValuesToUse) : null;

        if (appliedValues) {
          for (var prop in appliedValues) {
            definePropInterceptor(prop, this);
            actuallySet(this, prop, appliedValues[prop]);
          }
        }

        if (lastAppliedValues) {
          for (var prop$1 in lastAppliedValues) {
            if (!appliedValues || !(prop$1 in appliedValues)) {
              actuallySet(this, prop$1, this[(prop$1 + "➤pntr:baseValue")]);
            }
          }
        }
      };

      return PointerStatesAware;
    }(BaseFacadeClass));

    // Flag for identification
    Object.defineProperty(PointerStatesAware.prototype, 'isPointerStateAware', {value: true});

    // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it
    // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with
    // other custom setters anywhere else in the prototype chain.
    function definePropInterceptor(propName, currentInstance) {
      // On first set for this instance, move the prop's previous value, if any, to the private property
      var hasBeenSetProp = propName + "➤pntr:hasBeenSet";
      if (!currentInstance[hasBeenSetProp]) {
        currentInstance[(propName + "➤pntr:baseValue")] = currentInstance[propName];
        delete currentInstance[propName]; //remove own prop so it doesn't override the prototype getter/setter
        currentInstance[hasBeenSetProp] = true;
      }

      if (!PointerStatesAware.prototype.hasOwnProperty(propName)) {
        propsWithInterceptors[propName] = 1;
        var baseValueProp = propName + "➤pntr:baseValue";
        var appliedValueProp = propName + "➤pntr:appliedValue";

        Object.defineProperty(PointerStatesAware.prototype, propName, {
          get: function get() {
            var superGetter = getSuperGetter(propName);
            return superGetter ? superGetter.call(this) :
              (appliedValueProp in this) ? this[appliedValueProp] :
              this[baseValueProp]
          },

          set: function set(value) {
            this[baseValueProp] = value;
          }
        });
      }
    }

    function actuallySet(instance, propName, value) {
      var superSetter = getSuperSetter(propName);
      if (superSetter) {
        superSetter.call(instance, value);
      } else {
        instance[(propName + "➤pntr:appliedValue")] = value;
      }
    }

    function getSuperGetter(propName) {
      var proto = BaseFacadeClass.prototype;
      if (propName in proto) { //prefilter across entire proto chain
        while (proto) {
          var desc = Object.getOwnPropertyDescriptor(proto, propName);
          if (desc && desc.get) {
            return desc.get
          }
          proto = Object.getPrototypeOf(proto);
        }
      }
      return null
    }

    function getSuperSetter(propName) {
      var proto = BaseFacadeClass.prototype;
      if (propName in proto) { //prefilter across entire proto chain
        while (proto) {
          var desc = Object.getOwnPropertyDescriptor(proto, propName);
          if (desc && desc.set) {
            return desc.set
          }
          proto = Object.getPrototypeOf(proto);
        }
      }
      return null
    }

    function hoverOverHandler(e) {
      e.currentTarget[isHoveringProp] = true;
      afterPointerStateChange(e);
    }
    function hoverOutHandler(e) {
      e.currentTarget[isHoveringProp] = e.currentTarget[isActiveProp] = false;
      afterPointerStateChange(e);
    }
    function activeDownHandler(e) {
      e.currentTarget[isActiveProp] = true;
      afterPointerStateChange(e);
    }
    function activeUpHandler(e) {
      e.currentTarget[isActiveProp] = false;
      afterPointerStateChange(e);
    }

    function afterPointerStateChange(e) {
      var highestFacade = e.currentTarget;
      var parent = highestFacade.parent;
      while (parent && parent.shouldUpdateChildren()) {
        if (parent.isPointerStateAware) {
          highestFacade = parent;
        }
        parent = parent.parent;
      }
      highestFacade.afterUpdate();
      highestFacade.notifyWorld('needsRender');
    }

    return PointerStatesAware
  });

  /**
   * ListFacade is an optimized way to define a large number of scene objects based on an array of data.
   * Unlike mapping a data array to `children` objects in the scene descriptor, ListFacade allows you to
   * define only a single "template" descriptor object whose properties are either constant values
   * or accessor functions that get invoked for each data item. The resulting property values are
   * then applied directly to the implementation objects, without creating any intermediary objects.
   *
   * Example:
   *
   *     {
   *       key: 'balls',
   *       facade: ListFacade,
   *       data: itemsData,
   *       template: {
   *         key: (item, i, all) => `ball_${ item.id }`,
   *         facade: Ball,
   *         x: (item, i, all) => item.time,
   *         y: (item, i, all) => item.count,
   *         radius: 10,
   *         color: (item, i, all) => item.important ? 0xff0000 : 0xcccccc
   *       }
   *     }
   */
  var List = /*@__PURE__*/(function (Facade) {
    function List(parent) {
      Facade.call(this, parent);
      this._orderedItemKeys = [];
    }

    if ( Facade ) List.__proto__ = Facade;
    List.prototype = Object.create( Facade && Facade.prototype );
    List.prototype.constructor = List;

    List.prototype.afterUpdate = function afterUpdate () {
      var ref = this;
      var data = ref.data;
      var template = ref.template;
      var hasData = data && data.length && Array.isArray(data);

      // Allow the `template` to be defined as a JSX element, i.e. the result of React.createElement()
      // TODO almost works, except that React stringifies the `key` function
      // if (isReactElement(template)) {
      //   template.props.key = template.key
      //   template.props.facade = template.type
      //   template = template.props
      // }

      // Some basic validation in dev mode
      if (process.env.NODE_ENV !== 'production') {
        if (data && !Array.isArray(data)) {
          throw new Error('ListFacade "data" must be an array.')
        }
        if (!template || typeof template !== 'object') {
          throw new Error('ListFacade "template" must be an object.')
        }
        if (!template || typeof template.key !== 'function') {
          throw new Error('ListFacade template must define a "key" function.')
        }
        if (!template || typeof template.facade !== 'function') {
          throw new Error('ListFacade template must define a "facade".')
        }
      }

      if (this.shouldUpdateChildren()) {
        var oldDict = this._itemsDict || null;
        var newDict = this._itemsDict = hasData ? Object.create(null) : null;
        var orderedItemKeys = this._orderedItemKeys;

        if (hasData) {
          orderedItemKeys.length = data.length;

          for (var i = 0, len = data.length; i < len; i++) {
            var childData = data[i];
            var key = template.key(childData, i, data);
            var facadeClass = template.facade;

            // Some basic validation in dev mode
            if (process.env.NODE_ENV !== 'production') {
              if (key == null) {
                throw new Error('ListFacade template "key" function must return a key.')
              }
              if (newDict[key]) {
                console.warn(("Duplicate key in list: " + key));
              }
            }
            while(newDict[key]) {
              key += '|dupe';
            }

            // If a transition/animation is present, upgrade the class to a Animatable class on demand.
            // NOTE: changing between animatable/non-animatable results in a full teardown/recreation
            // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`
            // definition if the object is expected to ever need transitions, even if it's temporarily empty.
            var transition = typeof template.transition === 'function' ? template.transition(childData, i, data) : template.transition;
            var animation = typeof template.animation === 'function' ? template.animation(childData, i, data) : template.animation;
            var exitAnimation = typeof template.exitAnimation === 'function' ? template.exitAnimation(childData, i, data) : template.exitAnimation;
            if (transition || animation || exitAnimation) {
              facadeClass = extendAsAnimatable(facadeClass);
            }

            // Same for pointer states
            var pointerStates = template.pointerStates;
            if (pointerStates === 'function' ? pointerStates(childData, i, data) : pointerStates) {
              facadeClass = extendAsPointerStatesAware(facadeClass);
            }

            // If we have an old instance with the same key and class, reuse it; otherwise instantiate a new one
            var oldImpl = oldDict && oldDict[key];
            var newImpl = (void 0);
            if (oldImpl && oldImpl.constructor === facadeClass) {
              newImpl = oldImpl;
            } else {
              // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering
              if (oldImpl) { oldImpl.destructor(); }
              newImpl = new facadeClass(this);
            }
            //always set transition/animation before any other props
            newImpl.transition = transition;
            newImpl.animation = animation;
            for (var prop in template) {
              if (template.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
                newImpl[prop] = typeof template[prop] === 'function' ? template[prop](childData, i, data) : template[prop];
              }
            }
            newImpl.afterUpdate();
            newDict[key] = newImpl;
            orderedItemKeys[i] = key;
          }
        }

        // Destroy all old child instances that were not reused or replaced
        if (oldDict) {
          for (var key$1 in oldDict) {
            if (!newDict || !newDict[key$1]) {
              oldDict[key$1].destructor();
            }
          }
        }
      }

      Facade.prototype.afterUpdate.call(this);
    };

    /**
     * Override to selectively prevent updating the ListFacade's items on `afterUpdate`, for
     * potential performance gain.
     * @returns {boolean}
     */
    List.prototype.shouldUpdateChildren = function shouldUpdateChildren () {
      return true
    };

    /**
     * Walk this facade's descendant tree, invoking a function for it and each descendant.
     * The iteration order will match the order in which the `data` items were declared. It may
     * also include items that have been queued for removal but not yet removed, e.g. facades
     * in the process of an `exitAnimation`.
     * @param {Function} fn
     * @param {Object} [thisArg]
     */
    List.prototype.traverse = function traverse (fn, thisArg) {
      fn.call(thisArg, this);
      var keys = this._orderedItemKeys;
      var dict = this._itemsDict;
      for (var i = 0, len = keys.length; i < len; i++) {
        dict[keys[i]].traverse(fn, thisArg);
      }
    };

    /**
     * Iterate over this facade's direct child facades, invoking a function for each.
     * The iteration order will match the order in which the `data` items were declared. It may
     * also include items that have been queued for removal but not yet removed, e.g. facades
     * in the process of an `exitAnimation`.
     * @param {Function} fn
     * @param {Object} [thisArg]
     */
    List.prototype.forEachChild = function forEachChild (fn, thisArg) {
      var keys = this._orderedItemKeys;
      var dict = this._itemsDict;
      for (var i = 0, len = keys.length; i < len; i++) {
        fn.call(thisArg, dict[keys[i]], keys[i]);
      }
    };

    List.prototype.destructor = function destructor () {
      this.isDestroying = true;
      // Destroy all child instances
      var dict = this._itemsDict;
      if (dict) {
        for (var key in dict) {
          dict[key].destructor();
        }
      }
      Facade.prototype.destructor.call(this);
    };

    return List;
  }(Facade));

  var TEMP_ARRAY$1 = [null];

  /**
   * @typedef {object} FacadeDescriptor
   * An object describing the type and properties of a child facade to be created and managed by
   * its parent. See the detailed description in the docs for {@link Facade.js}.
   * @property {class} facade
   * @property {string|number} [key]
   */


  /**
   * Base facade class for objects that have `children`. Manages creating and destroying child
   * facade instances as needed as its `children` array changes.
   *
   * If you need to create a large number of child objects based on an array of incoming data,
   * consider using a `ListFacade` instead of a parent object with a large `children` array, since
   * that requires only a single template descriptor object instead of one for every child.
   */
  var ParentFacade = /*@__PURE__*/(function (Facade) {
    function ParentFacade(parent) {
      Facade.call(this, parent);

      /**
       * @member {FacadeDescriptor | Array<FacadeDescriptor>} children
       * Descriptors for one or more child facades.
       */
      this.children = null;

      this._orderedChildKeys = [];
    }

    if ( Facade ) ParentFacade.__proto__ = Facade;
    ParentFacade.prototype = Object.create( Facade && Facade.prototype );
    ParentFacade.prototype.constructor = ParentFacade;

    ParentFacade.prototype.afterUpdate = function afterUpdate () {
      if (this.shouldUpdateChildren()) {
        this.updateChildren(this.describeChildren());
      }
      Facade.prototype.afterUpdate.call(this);
    };

    /**
     * Return the descriptor(s) for the actual children to be created and managed. By default
     * this simply returns the value of the `children` property set by the parent, but you can
     * override it to customize how the child content should be structured, for instance to wrap
     * the `children` within a deeper structure, add in anonymous child siblings, or modify the
     * `children` configurations.
     * @protected
     * @return {FacadeDescriptor | Array<FacadeDescriptor>}
     */
    ParentFacade.prototype.describeChildren = function describeChildren () {
      return this.children
    };

    /**
     * Override to selectively prevent traversing to child nodes on `afterUpdate`, for
     * potential performance gain.
     * @returns {boolean}
     */
    ParentFacade.prototype.shouldUpdateChildren = function shouldUpdateChildren () {
      return true
    };

    ParentFacade.prototype.updateChildren = function updateChildren (children) {
      var oldDict = this._childrenDict || null;
      var newDict = this._childrenDict = null;
      var orderedChildKeys = this._orderedChildKeys;
      orderedChildKeys.length = 0;

      if (children) {
        // Allow single child without wrapper array
        if (!Array.isArray(children)) {
          TEMP_ARRAY$1[0] = children;
          children = TEMP_ARRAY$1;
        }

        for (var i = 0, len = children.length; i < len; i++) {
          var childDesc = children[i];
          if (!childDesc) { continue } //child members can be null
          if (!newDict) {
            newDict = this._childrenDict = Object.create(null);
          }

          // Handle child descriptors defined via a JSX->React.createElement() transforms (ReactElement objects)
          var isJSX = isReactElement(childDesc);
          var propsObj = isJSX ? childDesc.props : childDesc;
          var facadeClass = isJSX ? childDesc.type : childDesc.facade;

          // Find this child's key; if not specified by the author, build one from the facade class name
          var key = childDesc.key;
          if (!key) {
            var j = 0;
            do {
              key = "auto:" + (facadeClass.name) + ":" + (j++);
            } while (newDict[key])
          }

          // Some basic validation in dev mode
          if (process.env.NODE_ENV !== 'production') {
            if (typeof facadeClass !== 'function') {
              throw new Error('All scene objects must have a "facade" property pointing to a class/constructor')
            }
          }
          if (newDict[key]) {
            console.warn(("Duplicate key in children: " + key));
            while(newDict[key]) {
              key += '|dupe';
            }
          }

          // If a transition/animation is present, upgrade the class to a Animatable class on demand.
          // NOTE: changing between animatable/non-animatable results in a full teardown/recreation
          // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`
          // definition if the object is expected to ever need transitions, even if it's temporarily empty.
          var transition = propsObj.transition;
          var animation = propsObj.animation;
          if (transition || animation || propsObj.exitAnimation) {
            facadeClass = extendAsAnimatable(facadeClass);
          }

          // Same for pointer states
          if (propsObj.pointerStates) {
            facadeClass = extendAsPointerStatesAware(facadeClass);
          }

          // If we have an old instance with the same key and class, update it, otherwise instantiate a new one
          var oldImpl = oldDict && oldDict[key];
          var newImpl = (void 0);
          if (oldImpl && oldImpl.constructor === facadeClass) {
            newImpl = oldImpl;
          } else {
            // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering
            if (oldImpl) { oldImpl.destructor(); }
            newImpl = new facadeClass(this);
          }
          //always set transition/animation before any other props
          newImpl.transition = transition;
          newImpl.animation = animation;
          for (var prop in propsObj) {
            if (propsObj.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
              newImpl[prop] = propsObj[prop];
            }
          }
          newDict[key] = newImpl;
          orderedChildKeys.push(key);
          newImpl.afterUpdate();
        }
      }

      // Destroy all old child instances that were not reused or replaced
      if (oldDict) {
        for (var key$1 in oldDict) {
          if (!newDict || !newDict[key$1]) {
            oldDict[key$1].destructor();
          }
        }
      }
    };

    ParentFacade.prototype.getChildByKey = function getChildByKey (key) {
      var dict = this._childrenDict;
      return dict && dict[key] || null
    };

    /**
     * Walk this facade's descendant tree, invoking a function for it and each descendant.
     * The iteration order will match the order in which the `children` were declared. It may
     * also include items that have been queued for removal but not yet removed, e.g. facades
     * in the process of an `exitAnimation`.
     * @param {Function} fn
     * @param {Object} [thisArg]
     */
    ParentFacade.prototype.traverse = function traverse (fn, thisArg) {
      fn.call(thisArg, this);
      var keys = this._orderedChildKeys;
      var dict = this._childrenDict;
      for (var i = 0, len = keys.length; i < len; i++) {
        dict[keys[i]].traverse(fn, thisArg);
      }
    };

    /**
     * Iterate over this facade's direct child facades, invoking a function for each.
     * The iteration order will match the order in which the `children` were declared. It may
     * also include items that have been queued for removal but not yet removed, e.g. facades
     * in the process of an `exitAnimation`.
     * @param {Function} fn
     * @param {Object} [thisArg]
     */
    ParentFacade.prototype.forEachChild = function forEachChild (fn, thisArg) {
      var keys = this._orderedChildKeys;
      var dict = this._childrenDict;
      for (var i = 0, len = keys.length; i < len; i++) {
        fn.call(thisArg, dict[keys[i]], keys[i]);
      }
    };

    ParentFacade.prototype.destructor = function destructor () {
      this.isDestroying = true;
      // Destroy all child instances
      var dict = this._childrenDict;
      if (dict) {
        for (var key in dict) {
          dict[key].destructor();
        }
      }
      Facade.prototype.destructor.call(this);
    };

    return ParentFacade;
  }(Facade));

  var pointerMotionEventProps = [
    'onMouseOver',
    'onMouseOut',
    'onMouseMove',
    'onDragStart',
    'onDrag',
    'onDragEnter',
    'onDragOver',
    'onDragLeave'
  ];

  var pointerActionEventProps = [
    'onMouseDown',
    'onMouseUp',
    'onClick',
    'onDoubleClick',
    'onDrop',
    'onDragEnd',
    'onWheel'
  ];

  var pointerActionEventTypes = pointerActionEventProps.map(eventPropToType);
  var pointerMotionEventTypes = pointerMotionEventProps.map(eventPropToType);

  var pointerEventProps = pointerMotionEventProps.concat(pointerActionEventProps);
  var pointerEventTypes = pointerMotionEventTypes.concat(pointerActionEventTypes);

  function eventPropToType(prop) {
    return prop === 'onDoubleClick' ? 'dblclick' : prop.replace(/^on/, '').toLowerCase()
  }


  var PointerEventTarget = /*@__PURE__*/(function (ParentFacade) {
    function PointerEventTarget () {
      ParentFacade.apply(this, arguments);
    }

    if ( ParentFacade ) PointerEventTarget.__proto__ = ParentFacade;
    PointerEventTarget.prototype = Object.create( ParentFacade && ParentFacade.prototype );
    PointerEventTarget.prototype.constructor = PointerEventTarget;

    PointerEventTarget.prototype.interceptsPointerEvents = function interceptsPointerEvents (eventRegistry) {
      if (this.pointerEvents === false) {
        return false
      }
      if (this.pointerEvents) {
        return true
      }
      for (var i = 0, len = pointerEventTypes.length; i < len; i++) {
        if (eventRegistry.hasFacadeListenersOfType(this, pointerEventTypes[i])) {
          return true
        }
      }
    };

    return PointerEventTarget;
  }(ParentFacade));


  Object.defineProperty(PointerEventTarget.prototype, 'isPointerEventTarget', {value: true});


  // Add handlers for pointer event properties
  pointerEventProps.forEach(function (propName) {
    Facade.defineEventProperty(PointerEventTarget, propName, eventPropToType(propName));
  });

  /**
   * @class EventRegistry
   * Utility for tracking event listeners by type and target facade
   */
  function EventRegistry() {
    var this$1 = this;

    var byEventType = Object.create(null);

    this.addListenerForFacade = function (facade, type, handler) {
      var listenersOfType = byEventType[type] || (byEventType[type] = {
        count: 0,
        byFacadeId: Object.create(null)
      });
      var facadeId = facade.$facadeId;
      var oldHandlers = listenersOfType.byFacadeId[facadeId];
      // No listeners for this facade yet; set handler function as single value to avoid
      // unnecessary array creation in the common single-listener case.
      if (!oldHandlers) {
        listenersOfType.count++;
        listenersOfType.byFacadeId[facadeId] = handler;
      }
      // Already multiple listeners; add to array if not already present
      else if (Array.isArray(oldHandlers)) {
        if (oldHandlers.indexOf(handler) === -1) {
          listenersOfType.count++;
          oldHandlers.push(handler);
        }
      }
      // Second unique listener; promote to array
      else if (oldHandlers !== handler) {
        listenersOfType.count++;
        listenersOfType.byFacadeId[facadeId] = [oldHandlers, handler];
      }
    };

    this.removeListenerForFacade = function (facade, type, handler) {
      var listenersOfType = byEventType[type];
      var facadeId = facade.$facadeId;
      var oldHandlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
      // Single listener; delete from map
      if (oldHandlers === handler) {
        listenersOfType.count--;
        delete listenersOfType.byFacadeId[facadeId];
      }
      // Multiple listeners; remove from array
      else if (Array.isArray(oldHandlers)) {
        var idx = oldHandlers.indexOf(handler);
        if (idx > -1) {
          listenersOfType.count--;
          // Delete from map if the array will be empty; we don't demote from array to single
          // item because it can result in unneeded churn in the likely case of a different
          // listener being added immediately after
          if (oldHandlers.length === 1) {
            delete listenersOfType.byFacadeId[facadeId];
          } else {
            oldHandlers.splice(idx, 1);
          }
        }
      }
    };

    this.removeAllListenersForFacade = function (facade) {
      var facadeId = facade.$facadeId;
      for (var type in byEventType) {
        var facadeListeners = byEventType[type].byFacadeId[facadeId];
        if (facadeListeners) {
          byEventType[type].count -= (Array.isArray(facadeListeners) ? facadeListeners.length : 1);
          delete byEventType[type].byFacadeId[facadeId];
        }
      }
    };

    this.hasFacadeListenersOfType = function (facade, type) {
      return byEventType[type] ? !!byEventType[type].byFacadeId[facade.$facadeId] : false
    };

    this.hasAnyListenersOfType = function (type) {
      return byEventType[type] ? byEventType[type].count > 0 : false
    };

    this.findBubblingEventTarget = function (targetFacade, eventType) {
      while (targetFacade) {
        if (this$1.hasFacadeListenersOfType(targetFacade, eventType)) {
          return targetFacade
        }
        targetFacade = targetFacade.parent;
      }
      return null
    };

    function tryCall(func, scope, arg1, arg2) {
      try {
        func.call(scope, arg1, arg2);
      } catch(err) {
        console.error(err);
      }
    }

    this.forEachFacadeListenerOfType = function (facade, type, callback, scope) {
      var listenersOfType = byEventType[type];
      var facadeId = facade.$facadeId;
      var handlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
      if (handlers) {
        if (Array.isArray(handlers)) {
          for (var i = 0; i < handlers.length; i++) {
            tryCall(callback, scope, handlers[i], facadeId);
          }
        } else {
          tryCall(callback, scope, handlers, facadeId);
        }
      }
    };

    this.forEachListenerOfType = function (type, callback, scope) {
      var listenersOfType = byEventType[type];
      if (listenersOfType && listenersOfType.count > 0) {
        for (var facadeId in listenersOfType.byFacadeId) {
          var facadeListeners = listenersOfType.byFacadeId[facadeId];
          if (Array.isArray(facadeListeners)) {
            for (var i = 0; i < facadeListeners.length; i++) {
              tryCall(callback, scope, facadeListeners[i], facadeId);
            }
          } else {
            tryCall(callback, scope, facadeListeners, facadeId);
          }
        }
      }
    };

    this.dispatchEventOnFacade = function (facade, event) {
      var currentTarget = facade;
      function callHandler(handler) {
        handler.call(currentTarget, event);
      }
      event.target = facade;
      while (currentTarget && !event.propagationStopped) { //TODO should defaultPrevented mean anything here?
        event.currentTarget = currentTarget;
        this$1.forEachFacadeListenerOfType(currentTarget, event.type, callHandler, null);
        if (event.bubbles) {
          currentTarget = currentTarget.parent;
        } else {
          break
        }
      }
    };
  }

  var TAP_DISTANCE_THRESHOLD = 10;
  var TAP_GESTURE_MAX_DUR = 300;
  var TAP_DBLCLICK_MAX_DUR = 300;
  var DEFAULT_EVENT_SOURCE = {};

  var domPointerMotionEventTypes = [
    'mousemove',
    'mouseout',
    'touchmove'
  ];
  var domPointerActionEventTypes = [
    'mousedown',
    'mouseup',
    'click',
    'dblclick',
    'wheel',
    'touchstart',
    'touchend',
    'touchcancel'
  ];
  var dropEventTypes = [
    'mouseup',
    'touchend',
    'touchcancel'
  ];
  var pointerActionEventTypeMappings = {
    'touchstart': 'mousedown',
    'touchend': 'mouseup',
    'touchcancel': 'mouseup'
  };

  var touchDragPropsToNormalize = ['clientX', 'clientY', 'screenX', 'screenY', 'pageX', 'pageY'];

  var SyntheticEvent = function SyntheticEvent(nativeEvent, type, target, relatedTarget, extraProps) {
    var this$1 = this;

    // Copy native event properties - TODO investigate using a Proxy
    for (var prop in nativeEvent) {
      // NOTE: we don't check hasOwnProperty in this loop because properties that will return
      // false for properties that are defined by getters on inherited prototypes
      if (typeof nativeEvent[prop] !== 'function') {
        this[prop] = nativeEvent[prop];
      }
    }

    // Adjust to custom params
    this.target = target;
    this.relatedTarget = relatedTarget;
    this.type = type;
    this.nativeEvent = nativeEvent;
    assign(this, extraProps);

    // normalize position properties on touch events with a single touch, to facilitate
    // downstream handlers that expect them to look like mouse events
    // NOTE: can't do this in _normalizePointerEvent() as these props are unwritable on native Event objects
    if (nativeEvent.touches) {
      var touches = isTouchEndOrCancel(nativeEvent) ? nativeEvent.changedTouches : nativeEvent.touches;
      if (touches.length === 1) {
        touchDragPropsToNormalize.forEach(function (prop) {
          this$1[prop] = touches[0][prop];
        });
      }
    }
  };

  SyntheticEvent.prototype.preventDefault = function preventDefault () {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  };

  SyntheticEvent.prototype.stopPropagation = function stopPropagation () {
    this.propagationStopped = true;
    this.nativeEvent.stopPropagation();
  };

  function isTouchEndOrCancel(e) {
    return e.type === 'touchend' || e.type === 'touchcancel'
  }

  function killEvent(e) {
    e.stopPropagation();
    e.preventDefault();
  }


  var WorldBaseFacade = /*@__PURE__*/(function (ParentFacade) {
    function WorldBaseFacade(element) {
      ParentFacade.call(this, null);

      this.width = this.height = 1;
      this._element = element;
      this._htmlOverlays = Object.create(null);

      // Bind events
      this.eventRegistry = new EventRegistry();
      this._onPointerMotionEvent = this._onPointerMotionEvent.bind(this);
      this._onPointerActionEvent = this._onPointerActionEvent.bind(this);
      this._onDropEvent = this._onDropEvent.bind(this);
      this._togglePointerListeners(true);
    }

    if ( ParentFacade ) WorldBaseFacade.__proto__ = ParentFacade;
    WorldBaseFacade.prototype = Object.create( ParentFacade && ParentFacade.prototype );
    WorldBaseFacade.prototype.constructor = WorldBaseFacade;

    var prototypeAccessors = { renderingScheduler: { configurable: true } };

    WorldBaseFacade.prototype.afterUpdate = function afterUpdate () {
      this._queueRender();
      ParentFacade.prototype.afterUpdate.call(this);
    };

    WorldBaseFacade.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
      var handler = this._notifyWorldHandlers[message];
      if (handler) {
        handler.call(this, source, data);
      }
    };

    WorldBaseFacade.prototype._isContinuousRender = function _isContinuousRender () {
      return this.continuousRender
    };

    /**
     * @property {{requestAnimationFrame, cancelAnimationFrame}} renderingScheduler
     * The object holding `requestAnimationFrame` and `cancelAnimationFrame` scheduling
     * functions. Defaults to `window` but can be switched to another implementation, e.g.
     * to use an XRSession's custom scheduler.
     */
    prototypeAccessors.renderingScheduler.set = function (scheduler) {
      scheduler = scheduler || window;
      if (scheduler !== this.renderingScheduler) {
        var activeHandle = this._nextFrameTimer;
        if (activeHandle) {
          this.renderingScheduler.cancelAnimationFrame(activeHandle);
          this._nextFrameTimer = null;
        }
        this._renderingScheduler = scheduler;
      }
    };
    prototypeAccessors.renderingScheduler.get = function () {
      return this._renderingScheduler || window
    };

    // Schedule a render pass on the next frame
    WorldBaseFacade.prototype._queueRender = function _queueRender () {
      var this$1 = this;

      if (!this._nextFrameTimer) {
        var handler = this._nextFrameHandler || (this._nextFrameHandler = function () {
          var ref$1;

          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          var ref = this$1;
          var onStatsUpdate = ref.onStatsUpdate;
          var onBeforeRender = ref.onBeforeRender;
          var onAfterRender = ref.onAfterRender;
          var start = onStatsUpdate && Date.now();

          if (onBeforeRender) { onBeforeRender(this$1); }

          (ref$1 = this$1).doRender.apply(ref$1, args);

          if (onStatsUpdate) {
            var now = Date.now();
            onStatsUpdate({
              'Render CPU Time (ms)': now - start,
              'Time Between Frames (ms)': this$1._lastFrameTime ? now - this$1._lastFrameTime : '?',
              'FPS': this$1._lastFrameTime ? Math.round(1000 / (now - this$1._lastFrameTime)) : '?'
            });
            this$1._lastFrameTime = now;
          }

          this$1._doRenderHtmlItems();

          if (onAfterRender) { onAfterRender(this$1); }

          this$1._nextFrameTimer = null;

          if (this$1._isContinuousRender()) {
            this$1._queueRender();
          }
        });
        this._nextFrameTimer = this.renderingScheduler.requestAnimationFrame(handler);
      }
    };

    /**
     * @abstract
     */
    WorldBaseFacade.prototype.doRender = function doRender (/*...frameArgs*/) {
    };

    /**
     * @abstract
     */
    WorldBaseFacade.prototype.getFacadeUserSpaceXYZ = function getFacadeUserSpaceXYZ (facade) {
    };

    WorldBaseFacade.prototype._doRenderHtmlItems = function _doRenderHtmlItems () {
      if (this.renderHtmlItems) {
        var htmlItemsData = [];
        var overlayFacades = this._htmlOverlays;
        for (var key in overlayFacades) {
          var facade = overlayFacades[key];
          var data = this.getFacadeUserSpaceXYZ(facade);
          if (data.z >= 0) { //Ignore objects with negative z (behind the camera)
            data.key = facade.$facadeId;
            data.html = facade.html;
            data.exact = facade.exact;
            htmlItemsData.push(data);
          }
        }
        this.renderHtmlItems(htmlItemsData);
      }
    };

    /**
     * Hook allowing world implementations to pre-normalize native pointer events, for instance
     * computing derived worldspace properties that are simpler for downstream code to use.
     * @param {Event} e
     * @protected
     */
    WorldBaseFacade.prototype._normalizePointerEvent = function _normalizePointerEvent (e) {
    };

    /**
     * Entry point for handling events related to pointer motion (e.g. mouse or touch movement).
     * This will be called by the code that wraps this World facade to bridge native DOM events
     * into the Troika world.
     * @param {Event} e
     */
    WorldBaseFacade.prototype._onPointerMotionEvent = function _onPointerMotionEvent (e) {
      this._normalizePointerEvent(e);
      var eventState = this._getPointerEventState(e);

      if (pointerMotionEventTypes.some(this.eventRegistry.hasAnyListenersOfType)) {
        var hoverInfo = (e.type === 'mouseout' || isTouchEndOrCancel(e)) ? null : this._findHoverTarget(e);
        var lastHovered = eventState.hoveredFacade;
        var hovered = eventState.hoveredFacade = hoverInfo && hoverInfo.facade;

        var dragInfo = eventState.dragInfo;
        if (dragInfo) {
          if (!dragInfo.dragStartFired) {
            this._firePointerEvent('dragstart', dragInfo.dragStartEvent, dragInfo.draggedFacade, null, hoverInfo);
            dragInfo.dragStartFired = true;
          }
          this._firePointerEvent('drag', e, dragInfo.draggedFacade, null, hoverInfo);
        }

        if (hovered !== lastHovered) {
          if (lastHovered) {
            this._firePointerEvent('mouseout', e, lastHovered, hovered, hoverInfo);
            if (dragInfo) {
              this._firePointerEvent('dragleave', e, lastHovered, hovered, hoverInfo);
            }
          }
          if (hovered) {
            this._firePointerEvent('mouseover', e, hovered, lastHovered, hoverInfo);
            if (dragInfo) {
              this._firePointerEvent('dragenter', e, hovered, lastHovered, hoverInfo);
            }
          }
        }
        if (hovered) {
          this._firePointerEvent('mousemove', e, hovered, null, hoverInfo);
          if (dragInfo) {
            this._firePointerEvent('dragover', e, hovered, null, hoverInfo);
          }
        }
      }

      // Cancel tap gesture if moving past threshold
      var tapInfo = eventState.tapInfo;
      if (tapInfo && e.type === 'touchmove') {
        var touch = e.changedTouches[0];
        if (touch && Math.sqrt(Math.pow(touch.clientX - tapInfo.x, 2) + Math.pow(touch.clientY - tapInfo.y, 2)) > TAP_DISTANCE_THRESHOLD) {
          eventState.tapInfo = null;
        }
      }
    };

    /**
     * Entry point for handling events related to pointer motion (e.g. mouse clicks or touch taps).
     * This will be called by the code that wraps this World facade to bridge native DOM events
     * into the Troika world.
     * @param {Event} e
     */
    WorldBaseFacade.prototype._onPointerActionEvent = function _onPointerActionEvent (e) {
      this._normalizePointerEvent(e);

      // Handle drop events, in the case they weren't captured by the listeners on `document`
      // e.g. synthetic events dispatched internally
      if (dropEventTypes.indexOf(e.type) > -1) {
        this._onDropEvent(e);
      }

      // Map touch start to mouseover, and disable touch-hold context menu
      if (e.type === 'touchstart') {
        if (e.touches.length === 1) {
          this._onPointerMotionEvent(e);
        }
        this._enableContextMenu(false);
      }

      var eventRegistry = this.eventRegistry;
      if (eventRegistry.hasAnyListenersOfType('dragstart') || pointerActionEventTypes.some(eventRegistry.hasAnyListenersOfType)) {
        var hoverInfo = this._findHoverTarget(e);
        var facade = hoverInfo && hoverInfo.facade;
        if (facade) {
          var eventState = this._getPointerEventState(e);
          this._firePointerEvent(pointerActionEventTypeMappings[e.type] || e.type, e, facade, null, hoverInfo);

          // touchstart/touchend could be start/end of a tap - map to click
          if (eventRegistry.findBubblingEventTarget(facade, 'click') || eventRegistry.findBubblingEventTarget(facade, 'dblclick')) {
            var tapInfo = eventState.tapInfo;
            if (e.type === 'touchstart' && e.touches.length === 1) {
              eventState.tapInfo = {
                facade: facade,
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                startTime: Date.now(),
                isDblClick: tapInfo && Date.now() - tapInfo.startTime < TAP_DBLCLICK_MAX_DUR
              };
            } else {
              if (
                tapInfo && tapInfo.facade === facade && e.type === 'touchend' &&
                e.touches.length === 0 && e.changedTouches.length === 1 &&
                Date.now() - tapInfo.startTime < TAP_GESTURE_MAX_DUR
              ) {
                this._firePointerEvent('click', e, facade, null, hoverInfo);
                if (tapInfo.isDblClick) {
                  this._firePointerEvent('dblclick', e, facade, null, hoverInfo);
                }
              }
            }
          }

          // mousedown/touchstart could be prepping for drag gesture
          if (e.type === 'mousedown' || e.type === 'touchstart') {
            var dragger = eventRegistry.findBubblingEventTarget(facade, 'dragstart');
            if (dragger) {
              var dragStartEvent = new SyntheticEvent(e, 'dragstart', dragger, null, {intersection: hoverInfo});
              eventState.dragInfo = {
                draggedFacade: dragger,
                dragStartFired: false,
                dragStartEvent: dragStartEvent
              };
              // handle release outside canvas
              this._toggleDropListeners(true);
            }
          }
        }
        e.preventDefault(); //prevent e.g. touch scroll
      }

      // Map touch end to mouseout
      if (isTouchEndOrCancel(e)) {
        if (e.changedTouches.length === 1) {
          this._onPointerMotionEvent(e);
        }
        this._enableContextMenu(true);
      }
    };

    WorldBaseFacade.prototype._onDropEvent = function _onDropEvent (e) {
      var eventState = this._getPointerEventState(e);
      var dragInfo = eventState.dragInfo;
      if (dragInfo) {
        this._normalizePointerEvent(e);
        var hoverInfo = this._findHoverTarget(e);
        var targetFacade = hoverInfo && hoverInfo.facade;
        if (targetFacade) {
          this._firePointerEvent('drop', e, targetFacade, null, hoverInfo);
        }
        this._firePointerEvent('dragend', e, dragInfo.draggedFacade, null, hoverInfo);
        this._toggleDropListeners(false);
        eventState.dragInfo = null;
      }
    };

    WorldBaseFacade.prototype._firePointerEvent = function _firePointerEvent (eventType, originalEvent, targetFacade, relatedTargetFacade, intersection) {
      var newEvent = (originalEvent instanceof SyntheticEvent) ?
        originalEvent :
        new SyntheticEvent(
          originalEvent,
          eventType,
          targetFacade,
          relatedTargetFacade,
          {
            bubbles: true,
            intersection: intersection
          }
        );
      // Dispatch with bubbling
      this.eventRegistry.dispatchEventOnFacade(targetFacade, newEvent);
    };

    WorldBaseFacade.prototype._getPointerEventState = function _getPointerEventState (e) {
      var states = this._pointerEventStates || (this._pointerEventStates = new WeakMap());
      var eventSource = e.eventSource || DEFAULT_EVENT_SOURCE;
      var eventState = states.get(eventSource);
      if (!eventState) {
        states.set(eventSource, eventState = {});
      }
      return eventState
    };

    WorldBaseFacade.prototype._toggleDropListeners = function _toggleDropListeners (on) {
      var this$1 = this;

      dropEventTypes.forEach(function (type) {
        document[(on ? 'add' : 'remove') + 'EventListener'](type, this$1._onDropEvent, true);
      });
    };

    WorldBaseFacade.prototype._togglePointerListeners = function _togglePointerListeners (on) {
      var this$1 = this;

      var canvas = this._element;
      if (canvas && on !== this._pointerListenersAttached) {
        var method = (on ? 'add' : 'remove') + 'EventListener';
        domPointerMotionEventTypes.forEach(function (type) {
          canvas[method](type, this$1._onPointerMotionEvent, false);
        });
        domPointerActionEventTypes.forEach(function (type) {
          canvas[method](type, this$1._onPointerActionEvent, false);
        });
        this._pointerListenersAttached = on;
      }
    };

    WorldBaseFacade.prototype._enableContextMenu = function _enableContextMenu (enable) {
      var canvas = this._element;
      if (canvas) {
        canvas[(enable ? 'remove' : 'add') + 'EventListener']('contextmenu', killEvent, true);
      }
    };

    /**
     * @abstract
     * Given a pointer-related Event, find and return all facade objects that are intersected
     * by that event. If any hits are found, this should return an array of objects that contain
     * at least `facade` and `distance` properties. Any additional properties will be exposed to
     * event listeners on the synthetic event object as an `intersection` property.
     * @param {Event} e
     * @param {Function} [filterFn]
     * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
     */
    WorldBaseFacade.prototype.getFacadesAtEvent = function getFacadesAtEvent (e, filterFn) {
      throw new Error('getFacadesAtEvent: no impl')
    };

    WorldBaseFacade.prototype._findHoverTarget = function _findHoverTarget (e) {
      var this$1 = this;

      //only handle single touches for now
      if (e.touches && e.touches.length > 1) {
        return null
      }

      var allHits = this.getFacadesAtEvent(e, function (facade) { return facade.isPointerEventTarget && facade.interceptsPointerEvents(this$1.eventRegistry); }
      );
      if (allHits) {
        // Find the closest by comparing distance, or distanceBias if distance is the same
        var closestHit = allHits[0];
        for (var i = 1; i < allHits.length; i++) {
          if (allHits[i].distance < closestHit.distance ||
            (allHits[i].distance === closestHit.distance && (allHits[i].distanceBias || 0) < (closestHit.distanceBias || 0))
          ) {
            closestHit = allHits[i];
          }
        }
        return closestHit
      }

      return null
    };

    WorldBaseFacade.prototype.destructor = function destructor () {
      if (this._nextFrameTimer) {
        this.renderingScheduler.cancelAnimationFrame(this._nextFrameTimer);
      }
      this._togglePointerListeners(false);
      this._toggleDropListeners(false);
      ParentFacade.prototype.destructor.call(this);
    };

    Object.defineProperties( WorldBaseFacade.prototype, prototypeAccessors );

    return WorldBaseFacade;
  }(ParentFacade));

  Object.defineProperty(WorldBaseFacade.prototype, 'isWorld', {value: true});

  WorldBaseFacade.prototype._notifyWorldHandlers = {
    needsRender: function needsRender() {
      this._queueRender();
    },
    addEventListener: function addEventListener(source, data) {
      this.eventRegistry.addListenerForFacade(source, data.type, data.handler);
    },
    removeEventListener: function removeEventListener(source, data) {
      this.eventRegistry.removeListenerForFacade(source, data.type, data.handler);
    },
    removeAllEventListeners: function removeAllEventListeners(source) {
      this.eventRegistry.removeAllListenersForFacade(source);
    },
    dispatchEvent: function dispatchEvent(source, event) {
      if (!(event instanceof SyntheticEvent)) {
        event = new SyntheticEvent(event, event.type, event.target, event.relatedTarget);
      }
      this.eventRegistry.dispatchEventOnFacade(source, event);
    },
    addHtmlOverlay: function addHtmlOverlay(source) {
      this._htmlOverlays[source.$facadeId] = source;
    },
    removeHtmlOverlay: function removeHtmlOverlay(source) {
      delete this._htmlOverlays[source.$facadeId];
    },
    statsUpdate: function statsUpdate(source, data) {
      var onStatsUpdate = this.onStatsUpdate;
      if (onStatsUpdate) { onStatsUpdate(data); }
    }
  };

  var CT_STYLES = {
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: 'none',
    transformStyle: 'preserve-3d'
  };

  var HtmlOverlayContent = /*@__PURE__*/(function (superclass) {
    function HtmlOverlayContent () {
      superclass.apply(this, arguments);
    }

    if ( superclass ) HtmlOverlayContent.__proto__ = superclass;
    HtmlOverlayContent.prototype = Object.create( superclass && superclass.prototype );
    HtmlOverlayContent.prototype.constructor = HtmlOverlayContent;

    HtmlOverlayContent.prototype.shouldComponentUpdate = function shouldComponentUpdate (newProps) {
      return (
        newProps.html !== this.props.html ||
        (newProps.html.props && newProps.html.props.shouldUpdateOnMove) === true
      )
    };

    HtmlOverlayContent.prototype.render = function render () {
      var html = this.props.html;
      return typeof html === 'string'
        ? React.createElement('span', null, html)
        : React.cloneElement(html)
    };

    return HtmlOverlayContent;
  }(React.Component));

  HtmlOverlayContent.displayName = 'Canvas3D.HtmlOverlayContent';
  HtmlOverlayContent.propTypes = {
    html: T.node
  };

  var HtmlOverlay = /*@__PURE__*/(function (superclass) {
    function HtmlOverlay (props) {
      superclass.call(this, props);
      this.setItems = this.setItems.bind(this);
      this.state = {
        items: null
      };
    }

    if ( superclass ) HtmlOverlay.__proto__ = superclass;
    HtmlOverlay.prototype = Object.create( superclass && superclass.prototype );
    HtmlOverlay.prototype.constructor = HtmlOverlay;

    HtmlOverlay.prototype.shouldComponentUpdate = function shouldComponentUpdate (newProps, newState) {
      var oldState = this.state;
      return (
        (newState.items && newState.items.length) ||
        (oldState.items && oldState.items.length)
      )
    };

    HtmlOverlay.prototype.setItems = function setItems (items) {
      var lastItems = this.state.items;
      if ((items && items.length) || (lastItems && lastItems.length)) {
        this.setState({ items: items || null });
      }
    };

    HtmlOverlay.prototype.render = function render () {
      var items = this.state.items;
      var round = Math.round;
      return items && items.length
        ? React.createElement(
          'div',
          {
            className: 'troika_html_overlay',
            style: CT_STYLES
          },
          items.map(function (ref) {
            var key = ref.key;
            var html = ref.html;
            var x = ref.x;
            var y = ref.y;
            var z = ref.z;
            var exact = ref.exact;

            if (!exact) {
              x = round(x);
              y = round(y);
            }
            return React.createElement(
              'div',
              {
                key: key,
                style: {
                  position: 'absolute',
                  transform: ("translate3d(" + x + "px, " + y + "px, " + (-z) + "px)")
                }
              },
              React.createElement(HtmlOverlayContent, {html: html})
            )
          })
        )
        : null
    };

    return HtmlOverlay;
  }(React.Component));

  HtmlOverlay.displayName = 'Canvas3D.HtmlOverlay';

  var style = {
    position: 'absolute',
    top: 0,
    right: 0,
    background: 'rgba(0,0,0,.5)',
    font: '11px sans-serif',
    padding: 10
  };

  var Stats = /*@__PURE__*/(function (superclass) {
    function Stats(props) {
      superclass.call(this, props);
      this.state = {stats: {}};
    }

    if ( superclass ) Stats.__proto__ = superclass;
    Stats.prototype = Object.create( superclass && superclass.prototype );
    Stats.prototype.constructor = Stats;

    Stats.prototype.setStats = function setStats (stats) {
      this.setState({stats: stats});
    };

    Stats.prototype.render = function render () {
      var stats = this.state.stats;
      return (
        React.createElement(
          'div',
          {style: style},
          Object.keys(stats).sort().map(function (key) { return React.createElement('div', {key: key}, (key + ": " + (stats[key]))); }
          )
        )
      )
    };

    return Stats;
  }(React.Component));

  var defaultCanvasStyle = {width: '100%', height: '100%'};


  var CanvasBase = /*@__PURE__*/(function (superclass) {
    function CanvasBase(props) {
      superclass.call(this, props);
      this._stats = {};
      this.updateStats = this.updateStats.bind(this);
      this.renderHtmlItems = this.renderHtmlItems.bind(this);
      this._bindHtmlOverlayRef = this._bindHtmlOverlayRef.bind(this);
      this._bindCanvasRef = this._bindCanvasRef.bind(this);
      this._bindStatsRef = this._bindStatsRef.bind(this);
    }

    if ( superclass ) CanvasBase.__proto__ = superclass;
    CanvasBase.prototype = Object.create( superclass && superclass.prototype );
    CanvasBase.prototype.constructor = CanvasBase;

    CanvasBase.prototype.componentDidUpdate = function componentDidUpdate () {
      this.updateWorld();
    };

    CanvasBase.prototype.initWorld = function initWorld (canvas) {
      var world = new this.props.worldFacade(canvas);
      world.renderHtmlItems = this.renderHtmlItems;
      return world
    };

    CanvasBase.prototype.updateWorld = function updateWorld () {
      var world = this._world;
      if (world) {
        var ref = this;
        var props = ref.props;
        var useStats = props.stats;
        var start = useStats && Date.now();

        world.width = props.width;
        world.height = props.height;
        world.pixelRatio = props.pixelRatio;
        world.continuousRender = props.continuousRender;
        world.onStatsUpdate = useStats ? this.updateStats : null;
        assign(world, props.worldProps);
        world.afterUpdate();

        if (useStats) {
          this.updateStats({'Last World Update (ms)': Date.now() - start});
        }
      }
    };

    CanvasBase.prototype.destroyWorld = function destroyWorld () {
      //just to see it burn
      if (this._world) {
        this._world.destructor();
        delete this._world;
      }
      clearTimeout(this._statsDelay);
    };

    CanvasBase.prototype.renderHtmlItems = function renderHtmlItems (items) {
      if (this._htmlOverlayRef) {
        this._htmlOverlayRef.setItems(items);
      }
    };

    CanvasBase.prototype.updateStats = function updateStats (stats) {
      var this$1 = this;

      this._stats = assign({}, this._stats, stats);

      if (!this._statsDelay) {
        this._statsDelay = setTimeout(function () {
          this$1._statsDelay = null;
          var ref = this$1._statsRef;
          if (ref) {
            ref.setStats(this$1._stats);
          }
        }, 250);
      }
    };

    CanvasBase.prototype._bindHtmlOverlayRef = function _bindHtmlOverlayRef (cmp) {
      this._htmlOverlayRef = cmp;
    };

    CanvasBase.prototype._bindCanvasRef = function _bindCanvasRef (canvas) {
      if (canvas) {
        try {
          this._world = this.initWorld(canvas);
          this.updateWorld();
        } catch (e) {
          console.warn(("Troika." + (this.constructor.displayName) + ": world init failed, using fallback content."), e);
          this._failedWorldInit = true;
          this._world = null;
          this.forceUpdate();
        }
      } else {
        this.destroyWorld();
      }

      // Call external ref callback
      var cb = this.props.onCanvasRef;
      if (cb) { cb(canvas); }
    };

    CanvasBase.prototype._bindStatsRef = function _bindStatsRef (ref) {
      this._statsRef = ref;
    };

    CanvasBase.prototype.render = function render () {
      var ref = this;
      var props = ref.props;
      return (
        React.createElement(
          'div',
          {
            className: ("troika " + (props.className || '')),
            style: {
              position: 'relative',
              overflow: 'hidden',
              width: props.width,
              height: props.height,
              cursor: props.cursor,
              userSelect: 'none'
            }
          },
          this._failedWorldInit ? this.props.children : React.createElement(
            'canvas',
            {
              className: "troika_canvas",
              ref: this._bindCanvasRef,
              style: props.canvasStyle || defaultCanvasStyle
            }
          ),
          React.createElement(HtmlOverlay, {ref: this._bindHtmlOverlayRef}),
          props.stats ? React.createElement(Stats, {ref: this._bindStatsRef}) : null
        )
      )
    };

    return CanvasBase;
  }(React.Component));

  CanvasBase.commonPropTypes = {
    width: T.number.isRequired,
    height: T.number.isRequired,
    pixelRatio: T.number,
    worldFacade: T.func,
    worldProps: T.object,
    canvasStyle: T.object,
    className: T.string,
    continuousRender: T.bool,
    onCanvasRef: T.func,
    stats: T.bool,
    cursor: T.string
  };

  exports.Facade = Facade;
  exports.ListFacade = List;
  exports.ParentFacade = ParentFacade;
  exports.PointerEventTarget = PointerEventTarget;
  exports.ReactCanvasBase = CanvasBase;
  exports.WorldBaseFacade = WorldBaseFacade;
  exports.utils = utils;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
