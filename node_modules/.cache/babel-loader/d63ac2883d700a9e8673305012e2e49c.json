{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) : typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) : (global = global || self, factory(global.troika_three_utils = {}, global.THREE));\n})(this, function (exports, three) {\n  'use strict';\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n\n  var voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n\n  function expandShaderIncludes(source) {\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n    function replace(match, include) {\n      var chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match;\n    }\n\n    return source.replace(pattern, replace);\n  } // Local assign polyfill to avoid importing troika-core\n\n\n  var assign = Object.assign || function ()\n  /*target, ...sources*/\n  {\n    var arguments$1 = arguments;\n    var target = arguments[0];\n\n    for (var i = 1, len = arguments.length; i < len; i++) {\n      var source = arguments$1[i];\n\n      if (source) {\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var idCtr = 0;\n  var epoch = Date.now();\n  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n\n  function createDerivedMaterial(baseMaterial, options) {\n    // First check the cache to see if we've already derived from this baseMaterial using\n    // this unique set of options, and if so just return a clone instead of a new subclass\n    // which is faster and allows their shader program to be shared when rendering.\n    var optionsHash = getOptionsHash(options);\n    var cached = CACHE.get(baseMaterial);\n\n    if (!cached) {\n      cached = Object.create(null);\n      CACHE.set(baseMaterial, cached);\n    }\n\n    if (cached[optionsHash]) {\n      return cached[optionsHash].clone();\n    }\n\n    var id = ++idCtr;\n    var privateDerivedShadersProp = \"_derivedShaders\" + id;\n    var privateBeforeCompileProp = \"_onBeforeCompile\" + id;\n    var distanceMaterialTpl, depthMaterialTpl; // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n\n    function onBeforeCompile(shaderInfo) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo); // Upgrade the shaders, caching the result\n\n      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {\n        vertex: {},\n        fragment: {}\n      });\n      var vertex = ref.vertex;\n      var fragment = ref.fragment;\n\n      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {\n        var upgraded = upgradeShaders(shaderInfo, options, id);\n        vertex.source = shaderInfo.vertexShader;\n        vertex.result = upgraded.vertexShader;\n        fragment.source = shaderInfo.fragmentShader;\n        fragment.result = upgraded.fragmentShader;\n      } // Inject upgraded shaders and uniforms into the program\n\n\n      shaderInfo.vertexShader = vertex.result;\n      shaderInfo.fragmentShader = fragment.result;\n      assign(shaderInfo.uniforms, this.uniforms); // Inject auto-updating time uniform if requested\n\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {\n            return Date.now() - epoch;\n          }\n\n        };\n      } // Users can still add their own handlers on top of ours\n\n\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    }\n\n    function DerivedMaterial() {\n      baseMaterial.constructor.apply(this, arguments);\n      this._listeners = undefined; //don't inherit EventDispatcher listeners\n    }\n\n    DerivedMaterial.prototype = Object.create(baseMaterial, {\n      constructor: {\n        value: DerivedMaterial\n      },\n      isDerivedMaterial: {\n        value: true\n      },\n      baseMaterial: {\n        value: baseMaterial\n      },\n      onBeforeCompile: {\n        get: function get() {\n          return onBeforeCompile;\n        },\n        set: function set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n      copy: {\n        value: function value(source) {\n          baseMaterial.copy.call(this, source);\n\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            this.extensions = assign({}, source.extensions);\n            this.defines = assign({}, source.defines);\n            this.uniforms = three.UniformsUtils.clone(source.uniforms);\n          }\n\n          return this;\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {\n        value: function value() {\n          var depthMaterial = this._depthMaterial;\n\n          if (!depthMaterial) {\n            if (!depthMaterialTpl) {\n              depthMaterialTpl = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new three.MeshDepthMaterial({\n                depthPacking: three.RGBADepthPacking\n              }), options);\n              depthMaterialTpl.defines.IS_DEPTH_MATERIAL = '';\n            }\n\n            depthMaterial = this._depthMaterial = depthMaterialTpl.clone();\n            depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n\n          return depthMaterial;\n        }\n      },\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {\n        value: function value() {\n          var distanceMaterial = this._distanceMaterial;\n\n          if (!distanceMaterial) {\n            if (!distanceMaterialTpl) {\n              distanceMaterialTpl = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new three.MeshDistanceMaterial(), options);\n              distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = '';\n            }\n\n            distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();\n            distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n\n          return distanceMaterial;\n        }\n      },\n      dispose: {\n        value: function value() {\n          var ref = this;\n          var _depthMaterial = ref._depthMaterial;\n          var _distanceMaterial = ref._distanceMaterial;\n\n          if (_depthMaterial) {\n            _depthMaterial.dispose();\n          }\n\n          if (_distanceMaterial) {\n            _distanceMaterial.dispose();\n          }\n\n          baseMaterial.dispose.call(this);\n        }\n      }\n    });\n    var material = new DerivedMaterial();\n    material.copy(baseMaterial); // Merge uniforms, defines, and extensions\n\n    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);\n    material.defines = assign({}, baseMaterial.defines, options.defines);\n    material.defines.TROIKA_DERIVED_MATERIAL = id; //force a program change from the base material\n\n    material.extensions = assign({}, baseMaterial.extensions, options.extensions);\n    cached[optionsHash] = material;\n    return material.clone(); //return a clone so changes made to it don't affect the cached object\n  }\n\n  function upgradeShaders(ref, options, id) {\n    var vertexShader = ref.vertexShader;\n    var fragmentShader = ref.fragmentShader;\n    var vertexDefs = options.vertexDefs;\n    var vertexMainIntro = options.vertexMainIntro;\n    var vertexMainOutro = options.vertexMainOutro;\n    var vertexTransform = options.vertexTransform;\n    var fragmentDefs = options.fragmentDefs;\n    var fragmentMainIntro = options.fragmentMainIntro;\n    var fragmentMainOutro = options.fragmentMainOutro;\n    var fragmentColorTransform = options.fragmentColorTransform;\n    var customRewriter = options.customRewriter;\n    var timeUniform = options.timeUniform;\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || ''; // Expand includes if needed\n\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    } // Apply custom rewriter function\n\n\n    if (customRewriter) {\n      var res = customRewriter({\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader\n      });\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    } // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n\n\n    if (fragmentColorTransform) {\n      var postChunks = [];\n      fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      function (match) {\n        postChunks.push(match);\n        return '';\n      });\n      fragmentMainOutro = fragmentColorTransform + \"\\n\" + postChunks.join('\\n') + \"\\n\" + fragmentMainOutro;\n    } // Inject auto-updating time uniform if requested\n\n\n    if (timeUniform) {\n      var code = \"\\nuniform float \" + timeUniform + \";\\n\";\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    } // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n\n\n    if (vertexTransform) {\n      vertexDefs = vertexDefs + \"\\nvec3 troika_position_\" + id + \";\\nvec3 troika_normal_\" + id + \";\\nvec2 troika_uv_\" + id + \";\\nvoid troikaVertexTransform\" + id + \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \" + vertexTransform + \"\\n}\\n\";\n      vertexMainIntro = \"\\ntroika_position_\" + id + \" = vec3(position);\\ntroika_normal_\" + id + \" = vec3(normal);\\ntroika_uv_\" + id + \" = vec2(uv);\\ntroikaVertexTransform\" + id + \"(troika_position_\" + id + \", troika_normal_\" + id + \", troika_uv_\" + id + \");\\n\" + vertexMainIntro + \"\\n\";\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : \"troika_\" + match1 + \"_\" + id;\n      });\n    } // Inject defs and intro/outro snippets\n\n\n    vertexShader = injectIntoShaderCode(vertexShader, id, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, id, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n    return {\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    };\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, \"\\n\" + defs + \"\\nvoid troikaOrigMain\" + id + \"() {\");\n      shaderCode += \"\\nvoid main() {\\n  \" + intro + \"\\n  troikaOrigMain\" + id + \"();\\n  \" + outro + \"\\n}\";\n    }\n\n    return shaderCode;\n  }\n\n  function getOptionsHash(options) {\n    return JSON.stringify(options, optionsJsonReplacer);\n  }\n\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n  } // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n\n\n  var MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'phong',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n\n  function getShadersForMaterial(material) {\n    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n  }\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n\n\n  function getShaderUniformTypes(shader) {\n    var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n    var uniforms = Object.create(null);\n    var match;\n\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n\n    return uniforms;\n  }\n  /**\n   * @class ShaderFloatArray\n   *\n   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\n   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\n   * because:\n   *\n   *   - GLSL \"array\" uniforms can only be of a constant length.\n   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\n   *     extension is available.\n   *\n   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\n   * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\n   * and GLSL code for you to put in your custom shader to query the float values by array index.\n   *\n   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\n   * only allow texture lookups in fragment shaders.\n   *\n   * TODO:\n   *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\n   *   - Use a float texture if the extension is available so we can skip the encoding process\n   */\n\n\n  var ShaderFloatArray = function ShaderFloatArray(name) {\n    this.name = name;\n    this.textureUniform = \"dataTex_\" + name;\n    this.textureSizeUniform = \"dataTexSize_\" + name;\n    this.multiplierUniform = \"dataMultiplier_\" + name;\n    /**\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\n     * length of the data array.\n     * @type {string}\n     */\n\n    this.dataSizeUniform = \"dataSize_\" + name;\n    /**\n     * @property readFunction - the name of the GLSL function that should be called to\n     * read data out of the array by index.\n     * @type {string}\n     */\n\n    this.readFunction = \"readData_\" + name;\n    this._raw = new Float32Array(0);\n    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  };\n\n  var prototypeAccessors = {\n    length: {\n      configurable: true\n    }\n  };\n  /**\n   * @property length - the current length of the data array\n   * @type {number}\n   */\n\n  prototypeAccessors.length.set = function (value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      var size = Math.pow(2, Math.ceil(Math.log2(value)));\n      var raw = this._raw;\n\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      } else if (size > raw.length) {\n        this._raw = new Float32Array(size);\n\n        this._raw.set(raw);\n      }\n\n      this._length = value;\n    }\n  };\n\n  prototypeAccessors.length.get = function () {\n    return this._length;\n  };\n  /**\n   * Add a value to the end of the data array\n   * @param {number} value\n   */\n\n\n  ShaderFloatArray.prototype.push = function push(value) {\n    return this.set(this.length++, value);\n  };\n  /**\n   * Replace the existing data with that from a new array\n   * @param {ArrayLike<number>} array\n   */\n\n\n  ShaderFloatArray.prototype.setArray = function setArray(array) {\n    this.length = array.length;\n\n    this._raw.set(array);\n\n    this._needsRepack = true;\n  };\n  /**\n   * Get the current value at index\n   * @param {number} index\n   * @return {number}\n   */\n\n\n  ShaderFloatArray.prototype.get = function get(index) {\n    return this._raw[index];\n  };\n\n  ShaderFloatArray.prototype.set = function set(index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(value / this._multiplier, this._texture.image.data, index * 4);\n      this._needsMultCheck = true;\n    }\n  };\n  /**\n   * Make a copy of this ShaderFloatArray\n   * @return {ShaderFloatArray}\n   */\n\n\n  ShaderFloatArray.prototype.clone = function clone() {\n    var clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone;\n  };\n  /**\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\n   * @return {Object}\n   */\n\n\n  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms() {\n    var obj;\n    var me = this;\n    return obj = {}, obj[this.textureUniform] = {\n      get value() {\n        me._sync();\n\n        return me._texture;\n      }\n\n    }, obj[this.textureSizeUniform] = {\n      get value() {\n        me._sync();\n\n        return me._texture.image.width;\n      }\n\n    }, obj[this.dataSizeUniform] = {\n      get value() {\n        me._sync();\n\n        return me.length;\n      }\n\n    }, obj[this.multiplierUniform] = {\n      get value() {\n        me._sync();\n\n        return me._multiplier;\n      }\n\n    }, obj;\n  };\n  /**\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\n   * enable reading from the data array. This exposes a function with a name matching\n   * the {@link #readFunction} property, which other shader code can call to read values\n   * from the array by their index.\n   * @return {string}\n   */\n\n\n  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode() {\n    var ref = this;\n    var textureUniform = ref.textureUniform;\n    var textureSizeUniform = ref.textureSizeUniform;\n    var dataSizeUniform = ref.dataSizeUniform;\n    var multiplierUniform = ref.multiplierUniform;\n    var readFunction = ref.readFunction;\n    return \"\\nuniform sampler2D \" + textureUniform + \";\\nuniform float \" + textureSizeUniform + \";\\nuniform float \" + dataSizeUniform + \";\\nuniform float \" + multiplierUniform + \";\\n\\nfloat \" + readFunction + \"(float index) {\\n  vec2 texUV = vec2((index + 0.5) / \" + textureSizeUniform + \", 0.5);\\n  vec4 pixel = texture2D(\" + textureUniform + \", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * \" + multiplierUniform + \";\\n}\\n\";\n  };\n  /**\n   * @private Synchronize any pending changes to the underlying DataTexture\n   */\n\n\n  ShaderFloatArray.prototype._sync = function _sync() {\n    var tex = this._texture;\n    var raw = this._raw;\n    var needsRepack = this._needsRepack; // If the size of the raw array changed, resize the texture to match\n\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    } // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n\n\n    if (needsRepack || this._needsMultCheck) {\n      var maxVal = this._raw.reduce(function (a, b) {\n        return Math.max(a, b);\n      }, 0);\n\n      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    } // If things changed in a way we need to repack, do so\n\n\n    if (needsRepack) {\n      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);\n      }\n\n      this._needsRepack = false;\n    }\n  };\n\n  Object.defineProperties(ShaderFloatArray.prototype, prototypeAccessors);\n  /**\n   * Encode a floating point number into a set of four 8-bit integers.\n   * Also see the companion decoder function #decodeFloatFromFourInts.\n   *\n   * This is adapted to JavaScript from the basic approach at\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n   * but writes out integers in the range 0-255 instead of floats in the range 0-1\n   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\n   *\n   * Some precision will necessarily be lost during the encoding and decoding process.\n   * Testing shows that the maximum precision error is ~1.18e-10 which should be good\n   * enough for most cases.\n   *\n   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\n   *        otherwise the results will be incorrect.\n   * @param {Array|Uint8Array} array - an array into which the four ints should be written\n   * @param {Number} startIndex - index in the output array at which to start writing the ints\n   * @return {Array|Uint8Array}\n   */\n\n  function encodeFloatToFourInts(value, array, startIndex) {\n    // This is adapted to JS from the basic approach at\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    // but writes to a Uint8Array instead of floats. Input values must be in\n    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n    var enc0 = 255 * value;\n    var enc1 = 255 * (enc0 % 1);\n    var enc2 = 255 * (enc1 % 1);\n    var enc3 = 255 * (enc2 % 1);\n    enc0 = enc0 & 255;\n    enc1 = enc1 & 255;\n    enc2 = enc2 & 255;\n    enc3 = Math.round(enc3) & 255;\n    array[startIndex] = enc0;\n    array[startIndex + 1] = enc1;\n    array[startIndex + 2] = enc2;\n    array[startIndex + 3] = enc3;\n    return array;\n  }\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n\n  var vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\n  var vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\n  var fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\n  var fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\"; // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(baseMaterial, {\n      uniforms: {\n        pointA: {\n          value: new three.Vector3()\n        },\n        controlA: {\n          value: new three.Vector3()\n        },\n        controlB: {\n          value: new three.Vector3()\n        },\n        pointB: {\n          value: new three.Vector3()\n        },\n        radius: {\n          value: 0.01\n        },\n        dashing: {\n          value: new three.Vector3()\n        } //on, off, offset\n\n      },\n      vertexDefs: vertexDefs,\n      vertexTransform: vertexTransform,\n      fragmentDefs: fragmentDefs,\n      fragmentMainIntro: fragmentMainIntro\n    });\n  }\n\n  var geometry = null;\n  var defaultBaseMaterial = new three.MeshStandardMaterial({\n    color: 0xffffff,\n    side: three.DoubleSide\n  });\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n\n  var BezierMesh = /*@__PURE__*/function (Mesh) {\n    function BezierMesh() {\n      Mesh.call(this, BezierMesh.getGeometry(), defaultBaseMaterial);\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0; // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n\n      this.frustumCulled = false;\n    }\n\n    if (Mesh) BezierMesh.__proto__ = Mesh;\n    BezierMesh.prototype = Object.create(Mesh && Mesh.prototype);\n    BezierMesh.prototype.constructor = BezierMesh;\n    var prototypeAccessors = {\n      material: {\n        configurable: true\n      },\n      customDepthMaterial: {\n        configurable: true\n      },\n      customDistanceMaterial: {\n        configurable: true\n      }\n    }; // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n\n    BezierMesh.getGeometry = function getGeometry() {\n      return geometry || (geometry = new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    };\n\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultBaseMaterial;\n\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        if (derivedMaterial) {\n          derivedMaterial.dispose();\n        }\n\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial); // dispose the derived material when its base material is disposed:\n\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n\n      return derivedMaterial;\n    };\n\n    prototypeAccessors.material.set = function (baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    }; // Create and update material for shadows upon request:\n\n\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this.material.getDepthMaterial();\n    };\n\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this.material.getDistanceMaterial();\n    };\n\n    BezierMesh.prototype.onBeforeRender = function onBeforeRender(shaderInfo) {\n      var ref = this.material;\n      var uniforms = ref.uniforms;\n      var ref$1 = this;\n      var pointA = ref$1.pointA;\n      var controlA = ref$1.controlA;\n      var controlB = ref$1.controlB;\n      var pointB = ref$1.pointB;\n      var radius = ref$1.radius;\n      var dashArray = ref$1.dashArray;\n      var dashOffset = ref$1.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    };\n\n    BezierMesh.prototype.raycast = function raycast(raycaster, intersects) {// TODO - just fail for now\n    };\n\n    Object.defineProperties(BezierMesh.prototype, prototypeAccessors);\n    return BezierMesh;\n  }(three.Mesh);\n\n  exports.BezierMesh = BezierMesh;\n  exports.ShaderFloatArray = ShaderFloatArray;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.voidMainRegExp = voidMainRegExp;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/lairdkruger/Documents/Web Development/React Experiments/r3f-scroll-rig/node_modules/troika-three-utils/dist/troika-three-utils.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","troika_three_utils","THREE","three","voidMainRegExp","expandShaderIncludes","source","pattern","replace","match","include","chunk","ShaderChunk","assign","Object","arguments$1","arguments","target","i","len","length","prop","hasOwnProperty","idCtr","epoch","Date","now","CACHE","WeakMap","createDerivedMaterial","baseMaterial","options","optionsHash","getOptionsHash","cached","get","create","set","clone","id","privateDerivedShadersProp","privateBeforeCompileProp","distanceMaterialTpl","depthMaterialTpl","onBeforeCompile","shaderInfo","call","ref","vertex","fragment","vertexShader","fragmentShader","upgraded","upgradeShaders","result","uniforms","timeUniform","value","DerivedMaterial","constructor","apply","_listeners","undefined","prototype","isDerivedMaterial","fn","copy","isShaderMaterial","extensions","defines","UniformsUtils","getDepthMaterial","depthMaterial","_depthMaterial","MeshDepthMaterial","depthPacking","RGBADepthPacking","IS_DEPTH_MATERIAL","getDistanceMaterial","distanceMaterial","_distanceMaterial","MeshDistanceMaterial","IS_DISTANCE_MATERIAL","dispose","material","TROIKA_DERIVED_MATERIAL","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","res","postChunks","push","join","code","match1","index","fullStr","test","substr","injectIntoShaderCode","shaderCode","defs","intro","outro","JSON","stringify","optionsJsonReplacer","key","toString","MATERIAL_TYPES_TO_SHADERS","MeshNormalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","getShadersForMaterial","builtinType","type","ShaderLib","getShaderUniformTypes","shader","uniformRE","exec","ShaderFloatArray","name","textureUniform","textureSizeUniform","multiplierUniform","dataSizeUniform","readFunction","_raw","Float32Array","_texture","DataTexture","Uint8Array","_length","_multiplier","prototypeAccessors","configurable","size","Math","pow","ceil","log2","raw","subarray","setArray","array","_needsRepack","encodeFloatToFourInts","image","data","_needsMultCheck","getShaderUniforms","obj","me","_sync","width","getShaderHeaderCode","tex","needsRepack","height","maxVal","reduce","a","b","max","mult","needsUpdate","mult$1","defineProperties","startIndex","enc0","enc1","enc2","enc3","round","createBezierMeshMaterial","pointA","Vector3","controlA","controlB","pointB","radius","dashing","geometry","defaultBaseMaterial","color","side","DoubleSide","BezierMesh","Mesh","getGeometry","dashArray","Vector2","dashOffset","frustumCulled","__proto__","customDepthMaterial","customDistanceMaterial","CylinderBufferGeometry","translate","derivedMaterial","_derivedMaterial","_baseMaterial","addEventListener","onDispose","removeEventListener","onBeforeRender","ref$1","x","y","raycast","raycaster","intersects","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :\n  (global = global || self, factory(global.troika_three_utils = {}, global.THREE));\n}(this, (function (exports, three) { 'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  var voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      var chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  var assign = Object.assign || function(/*target, ...sources*/) {\n    var arguments$1 = arguments;\n\n    var target = arguments[0];\n    for (var i = 1, len = arguments.length; i < len; i++) {\n      var source = arguments$1[i];\n      if (source) {\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  var idCtr = 0;\n  var epoch = Date.now();\n  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support\n\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // First check the cache to see if we've already derived from this baseMaterial using\n    // this unique set of options, and if so just return a clone instead of a new subclass\n    // which is faster and allows their shader program to be shared when rendering.\n    var optionsHash = getOptionsHash(options);\n    var cached = CACHE.get(baseMaterial);\n    if (!cached) {\n      cached = Object.create(null);\n      CACHE.set(baseMaterial, cached);\n    }\n    if (cached[optionsHash]) {\n      return cached[optionsHash].clone()\n    }\n\n    var id = ++idCtr;\n    var privateDerivedShadersProp = \"_derivedShaders\" + id;\n    var privateBeforeCompileProp = \"_onBeforeCompile\" + id;\n    var distanceMaterialTpl, depthMaterialTpl;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    function onBeforeCompile(shaderInfo) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n      // Upgrade the shaders, caching the result\n      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {vertex: {}, fragment: {}});\n      var vertex = ref.vertex;\n      var fragment = ref.fragment;\n      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {\n        var upgraded = upgradeShaders(shaderInfo, options, id);\n        vertex.source = shaderInfo.vertexShader;\n        vertex.result = upgraded.vertexShader;\n        fragment.source = shaderInfo.fragmentShader;\n        fragment.result = upgraded.fragmentShader;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = vertex.result;\n      shaderInfo.fragmentShader = fragment.result;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    }\n\n    function DerivedMaterial() {\n      baseMaterial.constructor.apply(this, arguments);\n      this._listeners = undefined; //don't inherit EventDispatcher listeners\n    }\n    DerivedMaterial.prototype = Object.create(baseMaterial, {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n      baseMaterial: {value: baseMaterial},\n\n      onBeforeCompile: {\n        get: function get() {\n          return onBeforeCompile\n        },\n        set: function set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            this.extensions = assign({}, source.extensions);\n            this.defines = assign({}, source.defines);\n            this.uniforms = three.UniformsUtils.clone(source.uniforms);\n          }\n          return this\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {value: function() {\n        var depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          if (!depthMaterialTpl) {\n            depthMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({depthPacking: three.RGBADepthPacking}),\n              options\n            );\n            depthMaterialTpl.defines.IS_DEPTH_MATERIAL = '';\n          }\n          depthMaterial = this._depthMaterial = depthMaterialTpl.clone();\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }},\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {value: function() {\n        var distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          if (!distanceMaterialTpl) {\n            distanceMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = '';\n          }\n          distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }},\n\n      dispose: {value: function value() {\n        var ref = this;\n        var _depthMaterial = ref._depthMaterial;\n        var _distanceMaterial = ref._distanceMaterial;\n        if (_depthMaterial) { _depthMaterial.dispose(); }\n        if (_distanceMaterial) { _distanceMaterial.dispose(); }\n        baseMaterial.dispose.call(this);\n      }}\n    });\n\n    var material = new DerivedMaterial();\n    material.copy(baseMaterial);\n\n    // Merge uniforms, defines, and extensions\n    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);\n    material.defines = assign({}, baseMaterial.defines, options.defines);\n    material.defines.TROIKA_DERIVED_MATERIAL = id; //force a program change from the base material\n    material.extensions = assign({}, baseMaterial.extensions, options.extensions);\n\n    cached[optionsHash] = material;\n    return material.clone() //return a clone so changes made to it don't affect the cached object\n  }\n\n\n  function upgradeShaders(ref, options, id) {\n    var vertexShader = ref.vertexShader;\n    var fragmentShader = ref.fragmentShader;\n\n    var vertexDefs = options.vertexDefs;\n    var vertexMainIntro = options.vertexMainIntro;\n    var vertexMainOutro = options.vertexMainOutro;\n    var vertexTransform = options.vertexTransform;\n    var fragmentDefs = options.fragmentDefs;\n    var fragmentMainIntro = options.fragmentMainIntro;\n    var fragmentMainOutro = options.fragmentMainOutro;\n    var fragmentColorTransform = options.fragmentColorTransform;\n    var customRewriter = options.customRewriter;\n    var timeUniform = options.timeUniform;\n\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || '';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(\n        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n        '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n      );\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      var res = customRewriter({vertexShader: vertexShader, fragmentShader: fragmentShader});\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      var postChunks = [];\n      fragmentShader = fragmentShader.replace(\n        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n        function (match) {\n          postChunks.push(match);\n          return ''\n        }\n      );\n      fragmentMainOutro = fragmentColorTransform + \"\\n\" + (postChunks.join('\\n')) + \"\\n\" + fragmentMainOutro;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      var code = \"\\nuniform float \" + timeUniform + \";\\n\";\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      vertexDefs = vertexDefs + \"\\nvec3 troika_position_\" + id + \";\\nvec3 troika_normal_\" + id + \";\\nvec2 troika_uv_\" + id + \";\\nvoid troikaVertexTransform\" + id + \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \" + vertexTransform + \"\\n}\\n\";\n      vertexMainIntro = \"\\ntroika_position_\" + id + \" = vec3(position);\\ntroika_normal_\" + id + \" = vec3(normal);\\ntroika_uv_\" + id + \" = vec2(uv);\\ntroikaVertexTransform\" + id + \"(troika_position_\" + id + \", troika_normal_\" + id + \", troika_uv_\" + id + \");\\n\" + vertexMainIntro + \"\\n\";\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : (\"troika_\" + match1 + \"_\" + id)\n      });\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, id, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, id, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n    return {\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    }\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, (\"\\n\" + defs + \"\\nvoid troikaOrigMain\" + id + \"() {\")\n      );\n      shaderCode += \"\\nvoid main() {\\n  \" + intro + \"\\n  troikaOrigMain\" + id + \"();\\n  \" + outro + \"\\n}\";\n    }\n    return shaderCode\n  }\n\n  function getOptionsHash(options) {\n    return JSON.stringify(options, optionsJsonReplacer)\n  }\n\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  var MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'phong',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n    var uniforms = Object.create(null);\n    var match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * @class ShaderFloatArray\n   *\n   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\n   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\n   * because:\n   *\n   *   - GLSL \"array\" uniforms can only be of a constant length.\n   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\n   *     extension is available.\n   *\n   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\n   * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\n   * and GLSL code for you to put in your custom shader to query the float values by array index.\n   *\n   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\n   * only allow texture lookups in fragment shaders.\n   *\n   * TODO:\n   *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\n   *   - Use a float texture if the extension is available so we can skip the encoding process\n   */\n  var ShaderFloatArray = function ShaderFloatArray(name) {\n    this.name = name;\n    this.textureUniform = \"dataTex_\" + name;\n    this.textureSizeUniform = \"dataTexSize_\" + name;\n    this.multiplierUniform = \"dataMultiplier_\" + name;\n\n    /**\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\n     * length of the data array.\n     * @type {string}\n     */\n    this.dataSizeUniform = \"dataSize_\" + name;\n\n    /**\n     * @property readFunction - the name of the GLSL function that should be called to\n     * read data out of the array by index.\n     * @type {string}\n     */\n    this.readFunction = \"readData_\" + name;\n\n    this._raw = new Float32Array(0);\n    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  };\n\n  var prototypeAccessors = { length: { configurable: true } };\n\n  /**\n   * @property length - the current length of the data array\n   * @type {number}\n   */\n  prototypeAccessors.length.set = function (value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      var size = Math.pow(2, Math.ceil(Math.log2(value)));\n      var raw = this._raw;\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      }\n      else if(size > raw.length) {\n        this._raw = new Float32Array(size);\n        this._raw.set(raw);\n      }\n      this._length = value;\n    }\n  };\n  prototypeAccessors.length.get = function () {\n    return this._length\n  };\n\n  /**\n   * Add a value to the end of the data array\n   * @param {number} value\n   */\n  ShaderFloatArray.prototype.push = function push (value) {\n    return this.set(this.length++, value)\n  };\n\n  /**\n   * Replace the existing data with that from a new array\n   * @param {ArrayLike<number>} array\n   */\n  ShaderFloatArray.prototype.setArray = function setArray (array) {\n    this.length = array.length;\n    this._raw.set(array);\n    this._needsRepack = true;\n  };\n\n  /**\n   * Get the current value at index\n   * @param {number} index\n   * @return {number}\n   */\n  ShaderFloatArray.prototype.get = function get (index) {\n    return this._raw[index]\n  };\n\n  ShaderFloatArray.prototype.set = function set (index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(\n        value / this._multiplier,\n        this._texture.image.data,\n        index * 4\n      );\n      this._needsMultCheck = true;\n    }\n  };\n\n  /**\n   * Make a copy of this ShaderFloatArray\n   * @return {ShaderFloatArray}\n   */\n  ShaderFloatArray.prototype.clone = function clone () {\n    var clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone\n  };\n\n  /**\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\n   * @return {Object}\n   */\n  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms () {\n      var obj;\n\n    var me = this;\n    return ( obj = {}, obj[this.textureUniform] = {get value() {\n        me._sync();\n        return me._texture\n      }}, obj[this.textureSizeUniform] = {get value() {\n        me._sync();\n        return me._texture.image.width\n      }}, obj[this.dataSizeUniform] = {get value() {\n        me._sync();\n        return me.length\n      }}, obj[this.multiplierUniform] = {get value() {\n        me._sync();\n        return me._multiplier\n      }}, obj )\n  };\n\n  /**\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\n   * enable reading from the data array. This exposes a function with a name matching\n   * the {@link #readFunction} property, which other shader code can call to read values\n   * from the array by their index.\n   * @return {string}\n   */\n  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode () {\n    var ref = this;\n      var textureUniform = ref.textureUniform;\n      var textureSizeUniform = ref.textureSizeUniform;\n      var dataSizeUniform = ref.dataSizeUniform;\n      var multiplierUniform = ref.multiplierUniform;\n      var readFunction = ref.readFunction;\n    return (\"\\nuniform sampler2D \" + textureUniform + \";\\nuniform float \" + textureSizeUniform + \";\\nuniform float \" + dataSizeUniform + \";\\nuniform float \" + multiplierUniform + \";\\n\\nfloat \" + readFunction + \"(float index) {\\n  vec2 texUV = vec2((index + 0.5) / \" + textureSizeUniform + \", 0.5);\\n  vec4 pixel = texture2D(\" + textureUniform + \", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * \" + multiplierUniform + \";\\n}\\n\")\n  };\n\n  /**\n   * @private Synchronize any pending changes to the underlying DataTexture\n   */\n  ShaderFloatArray.prototype._sync = function _sync () {\n    var tex = this._texture;\n    var raw = this._raw;\n    var needsRepack = this._needsRepack;\n\n    // If the size of the raw array changed, resize the texture to match\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    }\n\n    // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n    if (needsRepack || this._needsMultCheck) {\n      var maxVal = this._raw.reduce(function (a, b) { return Math.max(a, b); }, 0);\n      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    }\n\n    // If things changed in a way we need to repack, do so\n    if (needsRepack) {\n      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);\n      }\n      this._needsRepack = false;\n    }\n  };\n\n  Object.defineProperties( ShaderFloatArray.prototype, prototypeAccessors );\n\n\n\n  /**\n   * Encode a floating point number into a set of four 8-bit integers.\n   * Also see the companion decoder function #decodeFloatFromFourInts.\n   *\n   * This is adapted to JavaScript from the basic approach at\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n   * but writes out integers in the range 0-255 instead of floats in the range 0-1\n   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\n   *\n   * Some precision will necessarily be lost during the encoding and decoding process.\n   * Testing shows that the maximum precision error is ~1.18e-10 which should be good\n   * enough for most cases.\n   *\n   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\n   *        otherwise the results will be incorrect.\n   * @param {Array|Uint8Array} array - an array into which the four ints should be written\n   * @param {Number} startIndex - index in the output array at which to start writing the ints\n   * @return {Array|Uint8Array}\n   */\n  function encodeFloatToFourInts(value, array, startIndex) {\n    // This is adapted to JS from the basic approach at\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    // but writes to a Uint8Array instead of floats. Input values must be in\n    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n    var enc0 = 255 * value;\n    var enc1 = 255 * (enc0 % 1);\n    var enc2 = 255 * (enc1 % 1);\n    var enc3 = 255 * (enc2 % 1);\n\n    enc0 = enc0 & 255;\n    enc1 = enc1 & 255;\n    enc2 = enc2 & 255;\n    enc3 = Math.round(enc3) & 255;\n\n    array[startIndex] = enc0;\n    array[startIndex + 1] = enc1;\n    array[startIndex + 2] = enc2;\n    array[startIndex + 3] = enc3;\n    return array\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  var vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\n\n  var vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\n\n  var fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\n\n  var fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs: vertexDefs,\n        vertexTransform: vertexTransform,\n        fragmentDefs: fragmentDefs,\n        fragmentMainIntro: fragmentMainIntro\n      }\n    )\n  }\n\n  var geometry = null;\n\n  var defaultBaseMaterial = new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  var BezierMesh = /*@__PURE__*/(function (Mesh) {\n    function BezierMesh() {\n      Mesh.call(\n        this, BezierMesh.getGeometry(),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    if ( Mesh ) BezierMesh.__proto__ = Mesh;\n    BezierMesh.prototype = Object.create( Mesh && Mesh.prototype );\n    BezierMesh.prototype.constructor = BezierMesh;\n\n    var prototypeAccessors = { material: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    BezierMesh.getGeometry = function getGeometry () {\n      return geometry || (geometry =\n        new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n      )\n    };\n\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultBaseMaterial;\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        if (derivedMaterial) {\n          derivedMaterial.dispose();\n        }\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    };\n    prototypeAccessors.material.set = function (baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    };\n\n    // Create and update material for shadows upon request:\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this.material.getDepthMaterial()\n    };\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this.material.getDistanceMaterial()\n    };\n\n    BezierMesh.prototype.onBeforeRender = function onBeforeRender (shaderInfo) {\n      var ref = this.material;\n      var uniforms = ref.uniforms;\n      var ref$1 = this;\n      var pointA = ref$1.pointA;\n      var controlA = ref$1.controlA;\n      var controlB = ref$1.controlB;\n      var pointB = ref$1.pointB;\n      var radius = ref$1.radius;\n      var dashArray = ref$1.dashArray;\n      var dashOffset = ref$1.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    };\n\n    BezierMesh.prototype.raycast = function raycast (raycaster, intersects) {\n      // TODO - just fail for now\n    };\n\n    Object.defineProperties( BezierMesh.prototype, prototypeAccessors );\n\n    return BezierMesh;\n  }(three.Mesh));\n\n  exports.BezierMesh = BezierMesh;\n  exports.ShaderFloatArray = ShaderFloatArray;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}