'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var React = require('react');
var React__default = _interopDefault(React);
var reactThreeFiber = require('react-three-fiber');
var OrbitControls$1 = require('three/examples/jsm/controls/OrbitControls');
var mergeRefs = _interopDefault(require('react-merge-refs'));
var TrackballControls$1 = require('three/examples/jsm/controls/TrackballControls');
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var TransformControls$1 = require('three/examples/jsm/controls/TransformControls');
var pick = _interopDefault(require('lodash.pick'));
var omit = _interopDefault(require('lodash.omit'));
var THREE = require('three');
var _construct = _interopDefault(require('@babel/runtime/helpers/construct'));
var postprocessing = require('postprocessing');
var textmeshStandalone_umd = require('troika-3d-text/dist/textmesh-standalone.umd');
var ReactDOM = _interopDefault(require('react-dom'));
var StatsImpl = _interopDefault(require('stats.js'));
var Sky$1 = require('three/examples/jsm/objects/Sky');
var LineGeometry = require('three/examples/jsm/lines/LineGeometry');
var LineMaterial = require('three/examples/jsm/lines/LineMaterial');
var Line2 = require('three/examples/jsm/lines/Line2');
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var DRACOLoader = require('three/examples/jsm/loaders/DRACOLoader');

reactThreeFiber.extend({
  OrbitControlsImpl: OrbitControls$1.OrbitControls
});
var OrbitControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  if (props === void 0) {
    props = {
      enableDamping: true
    };
  }

  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement("orbitControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement],
    enableDamping: true
  }, props));
});

reactThreeFiber.extend({
  MapControlsImpl: OrbitControls$1.MapControls
});
var MapControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  if (props === void 0) {
    props = {
      enableDamping: true
    };
  }

  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement("mapControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement],
    enableDamping: true
  }, props));
});

reactThreeFiber.extend({
  TrackballControlsImpl: TrackballControls$1.TrackballControls
});
var TrackballControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement("trackballControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, props));
});

reactThreeFiber.extend({
  TransformControlsImpl: TransformControls$1.TransformControls
});
var TransformControls = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var transformOnlyPropNames = ['enabled', 'axis', 'mode', 'translationSnap', 'rotationSnap', 'scaleSnap', 'space', 'size', 'dragging', 'showX', 'showY', 'showZ'];
  var transformProps = pick(props, transformOnlyPropNames);
  var objectProps = omit(props, transformOnlyPropNames);
  var controls = React.useRef();
  var group = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  React.useLayoutEffect(function () {
    var _controls$current;

    return void ((_controls$current = controls.current) == null ? void 0 : _controls$current.attach(group.current));
  }, [children]);
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("transformControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, transformProps)), /*#__PURE__*/React__default.createElement("group", _extends({
    ref: group
  }, objectProps), children));
});

var Detailed = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      distances = _ref.distances,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "distances"]);

  var lod = reactThreeFiber.useUpdate(function (lod) {
    lod.levels.length = 0;
    lod.children.forEach(function (object, index) {
      return lod.levels.push({
        object: object,
        distance: distances[index]
      });
    });
  }, []);
  reactThreeFiber.useFrame(function (state) {
    var _lod$current;

    return (_lod$current = lod.current) == null ? void 0 : _lod$current.update(state.camera);
  });
  return /*#__PURE__*/React__default.createElement("lOD", _extends({
    ref: mergeRefs([lod, ref])
  }, props), children);
});

var PositionalAudio = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var url = _ref.url,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 1 : _ref$distance,
      _ref$loop = _ref.loop,
      loop = _ref$loop === void 0 ? true : _ref$loop,
      props = _objectWithoutPropertiesLoose(_ref, ["url", "distance", "loop"]);

  var sound = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera;

  var _useState = React.useState(function () {
    return new THREE.AudioListener();
  }),
      listener = _useState[0];

  var buffer = reactThreeFiber.useLoader(THREE.AudioLoader, url);
  React.useEffect(function () {
    var _sound$current, _sound$current2, _sound$current3, _sound$current4;

    (_sound$current = sound.current) == null ? void 0 : _sound$current.setBuffer(buffer);
    (_sound$current2 = sound.current) == null ? void 0 : _sound$current2.setRefDistance(distance);
    (_sound$current3 = sound.current) == null ? void 0 : _sound$current3.setLoop(loop);
    (_sound$current4 = sound.current) == null ? void 0 : _sound$current4.play();
    camera.add(listener);
    return function () {
      return void camera.remove(listener);
    };
  }, []);
  return /*#__PURE__*/React__default.createElement("positionalAudio", _extends({
    ref: mergeRefs([sound, ref]),
    args: [listener]
  }, props));
});

var PerspectiveCamera = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      _ref$makeDefault = _ref.makeDefault,
      makeDefault = _ref$makeDefault === void 0 ? false : _ref$makeDefault,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "makeDefault"]);

  var _useThree = reactThreeFiber.useThree(),
      setDefaultCamera = _useThree.setDefaultCamera,
      camera = _useThree.camera,
      size = _useThree.size;

  var cameraRef = reactThreeFiber.useUpdate(function (cam) {
    cam.aspect = size.width / size.height;
    cam.updateProjectionMatrix();
  }, [size, props]);
  React.useLayoutEffect(function () {
    if (makeDefault) {
      var oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return function () {
        return setDefaultCamera(oldCam);
      };
    }
  }, []);
  return /*#__PURE__*/React__default.createElement("perspectiveCamera", _extends({
    ref: mergeRefs([cameraRef, ref])
  }, props), children);
});

var OrthographicCamera = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      _ref$makeDefault = _ref.makeDefault,
      makeDefault = _ref$makeDefault === void 0 ? false : _ref$makeDefault,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "makeDefault"]);

  var _useThree = reactThreeFiber.useThree(),
      setDefaultCamera = _useThree.setDefaultCamera,
      camera = _useThree.camera,
      size = _useThree.size;

  var cameraRef = reactThreeFiber.useUpdate(function (cam) {
    return cam.updateProjectionMatrix();
  }, [size, props]);
  React.useLayoutEffect(function () {
    if (makeDefault) {
      var oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return function () {
        return setDefaultCamera(oldCam);
      };
    }
  }, []);
  return /*#__PURE__*/React__default.createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: mergeRefs([cameraRef, ref])
  }, props), children);
});

function StandardEffects(_ref) {
  var _ref$smaa = _ref.smaa,
      smaa = _ref$smaa === void 0 ? true : _ref$smaa,
      _ref$ao = _ref.ao,
      ao = _ref$ao === void 0 ? true : _ref$ao,
      _ref$bloom = _ref.bloom,
      bloom = _ref$bloom === void 0 ? true : _ref$bloom,
      _ref$edgeDetection = _ref.edgeDetection,
      edgeDetection = _ref$edgeDetection === void 0 ? 0.1 : _ref$edgeDetection,
      _ref$bloomOpacity = _ref.bloomOpacity,
      bloomOpacity = _ref$bloomOpacity === void 0 ? 1 : _ref$bloomOpacity,
      effects = _ref.effects;

  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      scene = _useThree.scene,
      camera = _useThree.camera,
      size = _useThree.size;

  var smaaProps = reactThreeFiber.useLoader(postprocessing.SMAAImageLoader, '');
  var composer = React.useMemo(function () {
    var composer = new postprocessing.EffectComposer(gl, {
      frameBufferType: THREE.HalfFloatType
    });
    composer.addPass(new postprocessing.RenderPass(scene, camera));

    var smaaEffect = _construct(postprocessing.SMAAEffect, smaaProps);

    smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(edgeDetection);
    var normalPass = new postprocessing.NormalPass(scene, camera);
    var ssaoEffect = new postprocessing.SSAOEffect(camera, normalPass.renderTarget.texture, _extends({
      blendFunction: postprocessing.BlendFunction.MULTIPLY,
      samples: 21,
      // May get away with less samples
      rings: 4,
      // Just make sure this isn't a multiple of samples
      distanceThreshold: 1.0,
      distanceFalloff: 0.0,
      rangeThreshold: 0.015,
      // Controls sensitivity based on camera view distance **
      rangeFalloff: 0.002,
      luminanceInfluence: 0.9,
      radius: 20,
      // Spread range
      scale: 1.0,
      // Controls intensity **
      bias: 0.05
    }, ao));
    var bloomEffect = new postprocessing.BloomEffect(_extends({
      opacity: 1,
      blendFunction: postprocessing.BlendFunction.SCREEN,
      kernelSize: postprocessing.KernelSize.VERY_LARGE,
      luminanceThreshold: 0.9,
      luminanceSmoothing: 0.07,
      height: 600
    }, bloom));
    bloomEffect.blendMode.opacity.value = bloomOpacity;
    var effectsArray = [];
    if (effects) effectsArray = effects([smaaEffect, ssaoEffect, bloomEffect]);else {
      if (smaa) effectsArray.push(smaaEffect);
      if (ao) effectsArray.push(ssaoEffect);
      if (bloom) effectsArray.push(bloomEffect);
    }

    var effectPass = _construct(postprocessing.EffectPass, [camera].concat(effectsArray));

    effectPass.renderToScreen = true;
    composer.addPass(normalPass);
    composer.addPass(effectPass);
    return composer;
  }, [camera, gl, scene, smaa, ao, bloom, edgeDetection, bloomOpacity]);
  React.useEffect(function () {
    return void composer.setSize(size.width, size.height);
  }, [composer, size]);
  return reactThreeFiber.useFrame(function (_, delta) {
    return composer.render(delta);
  }, 1);
}

reactThreeFiber.extend({
  TextMeshImpl: textmeshStandalone_umd.TextMesh
});
var Text = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$anchorX = _ref.anchorX,
      anchorX = _ref$anchorX === void 0 ? 'center' : _ref$anchorX,
      _ref$anchorY = _ref.anchorY,
      anchorY = _ref$anchorY === void 0 ? 'middle' : _ref$anchorY,
      children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["anchorX", "anchorY", "children"]);

  var textRef = React.useRef();

  var _useState = React.useState(),
      baseMtl = _useState[0],
      setBaseMtl = _useState[1];

  var _useMemo = React.useMemo(function () {
    var n = [];
    var t = '';
    React.Children.forEach(children, function (child) {
      if (typeof child === 'string') t += child;else if (child && typeof child === 'object' && child.props.attach === 'material') {
        // Instantiate the base material and grab a reference to it, but don't assign any
        // props, and assign it as the `material`, which Troika will replace behind the scenes.
        n.push( /*#__PURE__*/React.createElement(child.type, {
          ref: setBaseMtl,
          attach: 'material'
        })); // Once the base material has been assigned, grab the resulting upgraded material,
        // and apply the original material props to that.

        if (baseMtl) {
          n.push( /*#__PURE__*/React__default.createElement("primitive", _extends({
            object: textRef.current.material
          }, child.props, {
            attach: null
          })));
        }
      } else n.push(child);
    });
    return [n, t];
  }, [children, baseMtl]),
      nodes = _useMemo[0],
      text = _useMemo[1];

  React.useLayoutEffect(function () {
    return void textRef.current.sync();
  });
  return /*#__PURE__*/React__default.createElement("textMeshImpl", _extends({
    ref: mergeRefs([textRef, ref]),
    text: text,
    anchorX: anchorX,
    anchorY: anchorY
  }, props), nodes);
});

var v1 = new THREE.Vector3();
var v2 = new THREE.Vector3();
var v3 = new THREE.Vector3();

function calculatePosition(el, camera, size) {
  var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  var widthHalf = size.width / 2;
  var heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}

function isObjectBehindCamera(el, camera) {
  var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  var cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  var deltaCamObj = objectPos.sub(cameraPos);
  var camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}

function objectScale(el, camera) {
  if (camera instanceof THREE.PerspectiveCamera) {
    var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    var cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    var vFOV = camera.fov * Math.PI / 180;
    var dist = objectPos.distanceTo(cameraPos);
    return 1 / (2 * Math.tan(vFOV / 2) * dist);
  }

  if (camera instanceof THREE.OrthographicCamera) return camera.zoom;
  return 1;
}

function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof THREE.PerspectiveCamera || camera instanceof THREE.OrthographicCamera) {
    var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    var cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    var dist = objectPos.distanceTo(cameraPos);
    var A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    var B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }

  return undefined;
}

var HTML = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _portal$current;

  var children = _ref.children,
      _ref$eps = _ref.eps,
      eps = _ref$eps === void 0 ? 0.001 : _ref$eps,
      style = _ref.style,
      className = _ref.className,
      prepend = _ref.prepend,
      center = _ref.center,
      fullscreen = _ref.fullscreen,
      portal = _ref.portal,
      scaleFactor = _ref.scaleFactor,
      _ref$zIndexRange = _ref.zIndexRange,
      zIndexRange = _ref$zIndexRange === void 0 ? [16777271, 0] : _ref$zIndexRange,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "eps", "style", "className", "prepend", "center", "fullscreen", "portal", "scaleFactor", "zIndexRange"]);

  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      scene = _useThree.scene,
      camera = _useThree.camera,
      size = _useThree.size;

  var _useState = React.useState(function () {
    return document.createElement('div');
  }),
      el = _useState[0];

  var group = React.useRef(null);
  var old = React.useRef([0, 0]);
  var target = (_portal$current = portal == null ? void 0 : portal.current) != null ? _portal$current : gl.domElement.parentNode;
  React.useEffect(function () {
    if (group.current) {
      scene.updateMatrixWorld();
      var vec = calculatePosition(group.current, camera, size);
      el.style.cssText = "position:absolute;top:0;left:0;transform:translate3d(" + vec[0] + "px," + vec[1] + "px,0);transform-origin:0 0;";

      if (target) {
        if (prepend) target.prepend(el);else target.appendChild(el);
      }

      return function () {
        if (target) target.removeChild(el);
        ReactDOM.unmountComponentAtNode(el);
      };
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [target]);
  var styles = React.useMemo(function () {
    return _extends({
      position: 'absolute',
      transform: center ? 'translate3d(-50%,-50%,0)' : 'none'
    }, fullscreen && {
      top: -size.height / 2,
      left: -size.width / 2,
      width: size.width,
      height: size.height
    }, style);
  }, [style, center, fullscreen, size]);
  React.useEffect(function () {
    return void ReactDOM.render( /*#__PURE__*/React__default.createElement("div", {
      ref: ref,
      style: styles,
      className: className,
      children: children
    }), el);
  });
  reactThreeFiber.useFrame(function () {
    if (group.current) {
      var vec = calculatePosition(group.current, camera, size);

      if (Math.abs(old.current[0] - vec[0]) > eps || Math.abs(old.current[1] - vec[1]) > eps) {
        el.style.display = !isObjectBehindCamera(group.current, camera) ? 'block' : 'none';
        var scale = scaleFactor === undefined ? 1 : objectScale(group.current, camera) * scaleFactor;
        el.style.transform = "translate3d(" + vec[0] + "px," + vec[1] + "px,0) scale(" + scale + ")";
        el.style.zIndex = "" + objectZIndex(group.current, camera, zIndexRange);
      }

      old.current = vec;
    }
  });
  return /*#__PURE__*/React__default.createElement("group", _extends({}, props, {
    ref: group
  }));
});

var Shadow = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$fog = _ref.fog,
      fog = _ref$fog === void 0 ? false : _ref$fog,
      _ref$colorStop = _ref.colorStop,
      colorStop = _ref$colorStop === void 0 ? 0.0 : _ref$colorStop,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'black' : _ref$color,
      _ref$opacity = _ref.opacity,
      opacity = _ref$opacity === void 0 ? 0.5 : _ref$opacity,
      props = _objectWithoutPropertiesLoose(_ref, ["fog", "colorStop", "color", "opacity"]);

  var canvas = React.useMemo(function () {
    var canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    var context = canvas.getContext('2d');
    var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
    gradient.addColorStop(colorStop, new THREE.Color(color).getStyle());
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
    return canvas;
  }, [color, stop]);
  return /*#__PURE__*/React__default.createElement("mesh", _extends({
    ref: ref
  }, props), /*#__PURE__*/React__default.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [1, 1]
  }), /*#__PURE__*/React__default.createElement("meshBasicMaterial", {
    attach: "material",
    transparent: true,
    opacity: opacity,
    fog: fog
  }, /*#__PURE__*/React__default.createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

function Stats(_ref) {
  var _ref$showPanel = _ref.showPanel,
      showPanel = _ref$showPanel === void 0 ? 0 : _ref$showPanel,
      className = _ref.className;

  var _useState = React.useState(function () {
    return new StatsImpl();
  }),
      stats = _useState[0];

  React.useEffect(function () {
    stats.showPanel(showPanel);
    document.body.appendChild(stats.dom);
    if (className) stats.dom.classList.add(className);
    return function () {
      return document.body.removeChild(stats.dom);
    };
  }, []);
  return reactThreeFiber.useFrame(function (state) {
    stats.begin();
    state.gl.render(state.scene, state.camera);
    stats.end();
  }, 1);
}

function WobbleMaterialImpl(parameters) {
  var _this = this;

  THREE.MeshStandardMaterial.call(this);
  this.setValues(parameters);
  this._time = {
    value: 0
  };
  this._factor = {
    value: 1
  };

  this.onBeforeCompile = function (shader) {
    shader.uniforms.time = _this._time;
    shader.uniforms.factor = _this._factor;
    shader.vertexShader = 'uniform float time; uniform float factor;\n' + shader.vertexShader;
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;");
  };

  Object.defineProperty(this, 'time', {
    get: function get() {
      return _this._time;
    },
    set: function set(val) {
      return _this._time.value = val;
    }
  });
  Object.defineProperty(this, 'factor', {
    get: function get() {
      return _this._factor;
    },
    set: function set(val) {
      return _this._factor.value = val;
    }
  });
}

WobbleMaterialImpl.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
WobbleMaterialImpl.prototype.constructor = THREE.MeshStandardMaterial;
WobbleMaterialImpl.prototype.isMeshStandardMaterial = true;
reactThreeFiber.extend({
  WobbleMaterialImpl: WobbleMaterialImpl
});
var MeshWobbleMaterial = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$speed = _ref.speed,
      speed = _ref$speed === void 0 ? 1 : _ref$speed,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  var material = React.useRef();
  reactThreeFiber.useFrame(function (state) {
    return material.current && (material.current.time = state.clock.getElapsedTime() * speed);
  });
  return /*#__PURE__*/React__default.createElement("wobbleMaterialImpl", _extends({
    ref: mergeRefs([ref, material]),
    attach: "material"
  }, props));
});

reactThreeFiber.extend({
  SkyImpl: Sky$1.Sky
});
var Sky = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 450000 : _ref$distance,
      _ref$sunPosition = _ref.sunPosition,
      sunPosition = _ref$sunPosition === void 0 ? [0, 1, 0] : _ref$sunPosition,
      props = _objectWithoutPropertiesLoose(_ref, ["distance", "sunPosition"]);

  var scale = React.useMemo(function () {
    return new THREE.Vector3().setScalar(distance);
  }, [distance]);
  return /*#__PURE__*/React__default.createElement("skyImpl", _extends({
    ref: ref,
    "material-uniforms-sunPosition-value": sunPosition,
    scale: scale
  }, props));
});

reactThreeFiber.extend({
  Line2: Line2.Line2,
  LineGeometry: LineGeometry.LineGeometry,
  LineMaterial: LineMaterial.LineMaterial
});
var Line = /*#__PURE__*/React__default.forwardRef(function Line(_ref, ref) {
  var points = _ref.points,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'black' : _ref$color,
      vertexColors = _ref.vertexColors,
      rest = _objectWithoutPropertiesLoose(_ref, ["points", "color", "vertexColors"]);

  var lineRef = React.useRef();
  var geomRef = React.useRef();
  var resolution = React.useMemo(function () {
    return new THREE.Vector2(512, 512);
  }, []);
  React.useEffect(function () {
    if (!geomRef.current || !lineRef.current) return;
    geomRef.current.setPositions(points.flat());
    if (vertexColors) geomRef.current.setColors(vertexColors.flat());
    lineRef.current.computeLineDistances();
  }, [points, vertexColors]);
  return /*#__PURE__*/React__default.createElement("line2", _extends({
    ref: mergeRefs([lineRef, ref])
  }, rest), /*#__PURE__*/React__default.createElement("lineGeometry", {
    attach: "geometry",
    ref: geomRef
  }), /*#__PURE__*/React__default.createElement("lineMaterial", _extends({
    attach: "material",
    color: color,
    vertexColors: Boolean(vertexColors),
    resolution: resolution
  }, rest)));
});

var StarfieldMaterial = /*#__PURE__*/function (_ShaderMaterial) {
  _inheritsLoose(StarfieldMaterial, _ShaderMaterial);

  function StarfieldMaterial() {
    return _ShaderMaterial.call(this, {
      uniforms: {
        time: {
          value: 0.0
        },
        fade: {
          value: 1.0
        }
      },
      vertexShader: "uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",
      fragmentShader: "uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n      }"
    }) || this;
  }

  return StarfieldMaterial;
}(THREE.ShaderMaterial);

reactThreeFiber.extend({
  StarfieldMaterial: StarfieldMaterial
});

var genStar = function genStar(r) {
  return new THREE.Vector3().setFromSpherical(new THREE.Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};

var Stars = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$radius = _ref.radius,
      radius = _ref$radius === void 0 ? 100 : _ref$radius,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? 50 : _ref$depth,
      _ref$count = _ref.count,
      count = _ref$count === void 0 ? 5000 : _ref$count,
      _ref$saturation = _ref.saturation,
      saturation = _ref$saturation === void 0 ? 0 : _ref$saturation,
      _ref$factor = _ref.factor,
      factor = _ref$factor === void 0 ? 4 : _ref$factor,
      _ref$fade = _ref.fade,
      fade = _ref$fade === void 0 ? false : _ref$fade;
  var material = React.useRef();

  var _useMemo = React.useMemo(function () {
    var positions = [];
    var colors = [];
    var sizes = Array.from({
      length: count
    }, function () {
      return (0.5 + 0.5 * Math.random()) * factor;
    });
    var color = new THREE.Color();
    var r = radius + depth;
    var increment = depth / count;

    for (var i = 0; i < count; i++) {
      r -= increment * Math.random();
      positions.push.apply(positions, genStar(r).toArray());
      color.setHSL(i / count, saturation, 0.9);
      colors.push(color.r, color.g, color.b);
    }

    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];
  }, []),
      position = _useMemo[0],
      color = _useMemo[1],
      size = _useMemo[2];

  reactThreeFiber.useFrame(function (state) {
    return material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime());
  });
  return /*#__PURE__*/React__default.createElement("points", {
    ref: ref
  }, /*#__PURE__*/React__default.createElement("bufferGeometry", {
    attach: "geometry"
  }, /*#__PURE__*/React__default.createElement("bufferAttribute", {
    attachObject: ['attributes', 'position'],
    args: [position, 3]
  }), /*#__PURE__*/React__default.createElement("bufferAttribute", {
    attachObject: ['attributes', 'color'],
    args: [color, 3]
  }), /*#__PURE__*/React__default.createElement("bufferAttribute", {
    attachObject: ['attributes', 'size'],
    args: [size, 1]
  })), /*#__PURE__*/React__default.createElement("starfieldMaterial", {
    ref: material,
    attach: "material",
    blending: THREE.AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

function draco(url) {
  if (url === void 0) {
    url = '/draco-gltf/';
  }

  return function (loader) {
    var dracoLoader = new DRACOLoader.DRACOLoader();
    dracoLoader.setDecoderPath(url);
    loader.setDRACOLoader(dracoLoader);
  };
}

var pcss = function pcss(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$frustrum = _ref.frustrum,
      frustrum = _ref$frustrum === void 0 ? 3.75 : _ref$frustrum,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 0.005 : _ref$size,
      _ref$near = _ref.near,
      near = _ref$near === void 0 ? 9.5 : _ref$near,
      _ref$samples = _ref.samples,
      samples = _ref$samples === void 0 ? 17 : _ref$samples,
      _ref$rings = _ref.rings,
      rings = _ref$rings === void 0 ? 11 : _ref$rings;

  return "#define LIGHT_WORLD_SIZE " + size + "\n#define LIGHT_FRUSTUM_WIDTH " + frustrum + "\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE " + near + "\n\n#define NUM_SAMPLES " + samples + "\n#define NUM_RINGS " + rings + "\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\tfloat angle = rand(randomSeed) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\tfor (int i = 0; i < NUM_SAMPLES; i++) {\n\t\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif (shadowMapDepth < zReceiver) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers++;\n\t\t}\n\t}\n\tif (numBlockers == 0) return -1.0;\n\treturn blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\tinitPoissonSamples(uv);\n\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\tif (avgBlockerDepth == -1.0) return 1.0;\n\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}";
};

var softShadows = function softShadows(props) {
  var shader = THREE.ShaderChunk.shadowmap_pars_fragment;
  shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\n' + pcss(_extends({}, props)));
  shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )');
  THREE.ShaderChunk.shadowmap_pars_fragment = shader;
};

var _inverseMatrix = new THREE.Matrix4();

var _ray = new THREE.Ray();

var _sphere = new THREE.Sphere();

var _vA = new THREE.Vector3();

function meshBounds(raycaster, intersects) {
  var geometry = this.geometry;
  var material = this.material;
  var matrixWorld = this.matrixWorld;
  if (material === undefined) return; // Checking boundingSphere distance to ray

  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

  _sphere.copy(geometry.boundingSphere);

  _sphere.applyMatrix4(matrixWorld);

  if (raycaster.ray.intersectsSphere(_sphere) === false) return;

  _inverseMatrix.getInverse(matrixWorld);

  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;
  intersects.push({
    distance: _vA.distanceTo(raycaster.ray.origin),
    point: _vA.clone(),
    object: this
  });
}

function useCamera(camera, props) {
  var _useThree = reactThreeFiber.useThree(),
      mouse = _useThree.mouse;

  var _useState = React.useState(function () {
    var raycaster = new THREE.Raycaster();
    if (props) reactThreeFiber.applyProps(raycaster, props, {});
    return function (_, intersects) {
      raycaster.setFromCamera(mouse, camera instanceof THREE.Camera ? camera : camera.current);
      var rc = this.constructor.prototype.raycast.bind(this);
      if (rc) rc(raycaster, intersects);
    };
  }),
      raycast = _useState[0];

  return raycast;
}

function useHelper(object3D, proto) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var helper = React__default.useRef();

  var _useThree = reactThreeFiber.useThree(),
      scene = _useThree.scene;

  React.useEffect(function () {
    if (proto && object3D.current) {
      helper.current = _construct(proto, [object3D.current].concat(args));

      if (helper.current) {
        scene.add(helper.current);
      }
    }

    return function () {
      if (helper.current) {
        scene.remove(helper.current);
      }
    };
  }, [scene, proto, object3D, args]);
  reactThreeFiber.useFrame(function () {
    if (helper.current) {
      helper.current.update();
    }
  });
  return helper;
}

function useAspect(type, width, height, factor) {
  if (factor === void 0) {
    factor = 1;
  }

  var _useThree = reactThreeFiber.useThree(),
      v = _useThree.viewport,
      aspect = _useThree.aspect;

  var adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);
  var adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

function create(type) {
  var El = type + 'BufferGeometry';
  return /*#__PURE__*/React.forwardRef(function (_ref, ref) {
    var args = _ref.args,
        children = _ref.children,
        props = _objectWithoutPropertiesLoose(_ref, ["args", "children"]);

    return /*#__PURE__*/React__default.createElement("mesh", _extends({
      ref: ref
    }, props), /*#__PURE__*/React__default.createElement(El, {
      attach: "geometry",
      args: args
    }), children);
  });
}

var Box = create('box');
var Circle = create('circle');
var Cone = create('cone');
var Cylinder = create('cylinder');
var Sphere = create('sphere');
var Plane = create('plane');
var Tube = create('tube');
var Torus = create('torus');
var TorusKnot = create('torusKnot');
var Tetrahedron = create('tetrahedron');
var Ring = create('ring');
var Polyhedron = create('polyhedron');
var Icosahedron = create('icosahedron');
var Octahedron = create('octahedron');
var Dodecahedron = create('dodecahedron');
var Extrude = create('extrude');
var Lathe = create('lathe');
var Parametric = create('parametric');

exports.Box = Box;
exports.Circle = Circle;
exports.Cone = Cone;
exports.Cylinder = Cylinder;
exports.Detailed = Detailed;
exports.Dodecahedron = Dodecahedron;
exports.Extrude = Extrude;
exports.HTML = HTML;
exports.Icosahedron = Icosahedron;
exports.Lathe = Lathe;
exports.Line = Line;
exports.MapControls = MapControls;
exports.MeshWobbleMaterial = MeshWobbleMaterial;
exports.Octahedron = Octahedron;
exports.OrbitControls = OrbitControls;
exports.OrthographicCamera = OrthographicCamera;
exports.Parametric = Parametric;
exports.PerspectiveCamera = PerspectiveCamera;
exports.Plane = Plane;
exports.Polyhedron = Polyhedron;
exports.PositionalAudio = PositionalAudio;
exports.Ring = Ring;
exports.Shadow = Shadow;
exports.Sky = Sky;
exports.Sphere = Sphere;
exports.StandardEffects = StandardEffects;
exports.Stars = Stars;
exports.Stats = Stats;
exports.Tetrahedron = Tetrahedron;
exports.Text = Text;
exports.Torus = Torus;
exports.TorusKnot = TorusKnot;
exports.TrackballControls = TrackballControls;
exports.TransformControls = TransformControls;
exports.Tube = Tube;
exports.draco = draco;
exports.meshBounds = meshBounds;
exports.softShadows = softShadows;
exports.useAspect = useAspect;
exports.useCamera = useCamera;
exports.useHelper = useHelper;
