import _extends from '@babel/runtime/helpers/esm/extends';
import React, { forwardRef, useRef, useEffect, useLayoutEffect, useState, useMemo, Children, createElement } from 'react';
import { extend, useThree, useFrame, useUpdate, useLoader, applyProps } from 'react-three-fiber';
import { OrbitControls as OrbitControls$1, MapControls as MapControls$1 } from 'three/examples/jsm/controls/OrbitControls';
import mergeRefs from 'react-merge-refs';
import { TrackballControls as TrackballControls$1 } from 'three/examples/jsm/controls/TrackballControls';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { TransformControls as TransformControls$1 } from 'three/examples/jsm/controls/TransformControls';
import pick from 'lodash.pick';
import omit from 'lodash.omit';
import { AudioListener, AudioLoader, HalfFloatType, Vector3, PerspectiveCamera as PerspectiveCamera$1, OrthographicCamera as OrthographicCamera$1, Color, MeshStandardMaterial, Vector2, Spherical, AdditiveBlending, ShaderMaterial, ShaderChunk, Matrix4, Ray, Sphere as Sphere$1, Raycaster, Camera } from 'three';
import { SMAAImageLoader, EffectComposer, RenderPass, SMAAEffect, NormalPass, SSAOEffect, BlendFunction, BloomEffect, KernelSize, EffectPass } from 'postprocessing';
import { TextMesh } from 'troika-3d-text/dist/textmesh-standalone.umd';
import ReactDOM from 'react-dom';
import StatsImpl from 'stats.js';
import { Sky as Sky$1 } from 'three/examples/jsm/objects/Sky';
import { LineGeometry } from 'three/examples/jsm/lines/LineGeometry';
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial';
import { Line2 } from 'three/examples/jsm/lines/Line2';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';

extend({
  OrbitControlsImpl: OrbitControls$1
});
const OrbitControls = /*#__PURE__*/forwardRef((props = {
  enableDamping: true
}, ref) => {
  const controls = useRef();
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  useFrame(() => {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  useEffect(() => {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return () => {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React.createElement("orbitControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement],
    enableDamping: true
  }, props));
});

extend({
  MapControlsImpl: MapControls$1
});
const MapControls = /*#__PURE__*/forwardRef((props = {
  enableDamping: true
}, ref) => {
  const controls = useRef();
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  useFrame(() => {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  useEffect(() => {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return () => {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React.createElement("mapControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement],
    enableDamping: true
  }, props));
});

extend({
  TrackballControlsImpl: TrackballControls$1
});
const TrackballControls = /*#__PURE__*/forwardRef((props, ref) => {
  const controls = useRef();
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  useFrame(() => {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  useEffect(() => {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return () => {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React.createElement("trackballControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, props));
});

extend({
  TransformControlsImpl: TransformControls$1
});
const TransformControls = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const transformOnlyPropNames = ['enabled', 'axis', 'mode', 'translationSnap', 'rotationSnap', 'scaleSnap', 'space', 'size', 'dragging', 'showX', 'showY', 'showZ'];
  const transformProps = pick(props, transformOnlyPropNames);
  const objectProps = omit(props, transformOnlyPropNames);
  const controls = useRef();
  const group = useRef();
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  useLayoutEffect(() => {
    var _controls$current;

    return void ((_controls$current = controls.current) == null ? void 0 : _controls$current.attach(group.current));
  }, [children]);
  useEffect(() => {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return () => {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("transformControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, transformProps)), /*#__PURE__*/React.createElement("group", _extends({
    ref: group
  }, objectProps), children));
});

const Detailed = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    distances
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "distances"]);

  const lod = useUpdate(lod => {
    lod.levels.length = 0;
    lod.children.forEach((object, index) => lod.levels.push({
      object,
      distance: distances[index]
    }));
  }, []);
  useFrame(state => {
    var _lod$current;

    return (_lod$current = lod.current) == null ? void 0 : _lod$current.update(state.camera);
  });
  return /*#__PURE__*/React.createElement("lOD", _extends({
    ref: mergeRefs([lod, ref])
  }, props), children);
});

const PositionalAudio = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    url,
    distance = 1,
    loop = true
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["url", "distance", "loop"]);

  const sound = useRef();
  const {
    camera
  } = useThree();
  const [listener] = useState(() => new AudioListener());
  const buffer = useLoader(AudioLoader, url);
  useEffect(() => {
    var _sound$current, _sound$current2, _sound$current3, _sound$current4;

    (_sound$current = sound.current) == null ? void 0 : _sound$current.setBuffer(buffer);
    (_sound$current2 = sound.current) == null ? void 0 : _sound$current2.setRefDistance(distance);
    (_sound$current3 = sound.current) == null ? void 0 : _sound$current3.setLoop(loop);
    (_sound$current4 = sound.current) == null ? void 0 : _sound$current4.play();
    camera.add(listener);
    return () => void camera.remove(listener);
  }, []);
  return /*#__PURE__*/React.createElement("positionalAudio", _extends({
    ref: mergeRefs([sound, ref]),
    args: [listener]
  }, props));
});

const PerspectiveCamera = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    makeDefault = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "makeDefault"]);

  const {
    setDefaultCamera,
    camera,
    size
  } = useThree();
  const cameraRef = useUpdate(cam => {
    cam.aspect = size.width / size.height;
    cam.updateProjectionMatrix();
  }, [size, props]);
  useLayoutEffect(() => {
    if (makeDefault) {
      const oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return () => setDefaultCamera(oldCam);
    }
  }, []);
  return /*#__PURE__*/React.createElement("perspectiveCamera", _extends({
    ref: mergeRefs([cameraRef, ref])
  }, props), children);
});

const OrthographicCamera = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    makeDefault = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "makeDefault"]);

  const {
    setDefaultCamera,
    camera,
    size
  } = useThree();
  const cameraRef = useUpdate(cam => cam.updateProjectionMatrix(), [size, props]);
  useLayoutEffect(() => {
    if (makeDefault) {
      const oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return () => setDefaultCamera(oldCam);
    }
  }, []);
  return /*#__PURE__*/React.createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: mergeRefs([cameraRef, ref])
  }, props), children);
});

function StandardEffects({
  smaa = true,
  ao = true,
  bloom = true,
  edgeDetection = 0.1,
  bloomOpacity = 1,
  effects
}) {
  const {
    gl,
    scene,
    camera,
    size
  } = useThree();
  const smaaProps = useLoader(SMAAImageLoader, '');
  const composer = useMemo(() => {
    const composer = new EffectComposer(gl, {
      frameBufferType: HalfFloatType
    });
    composer.addPass(new RenderPass(scene, camera));
    const smaaEffect = new SMAAEffect(...smaaProps);
    smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(edgeDetection);
    const normalPass = new NormalPass(scene, camera);
    const ssaoEffect = new SSAOEffect(camera, normalPass.renderTarget.texture, _extends({
      blendFunction: BlendFunction.MULTIPLY,
      samples: 21,
      // May get away with less samples
      rings: 4,
      // Just make sure this isn't a multiple of samples
      distanceThreshold: 1.0,
      distanceFalloff: 0.0,
      rangeThreshold: 0.015,
      // Controls sensitivity based on camera view distance **
      rangeFalloff: 0.002,
      luminanceInfluence: 0.9,
      radius: 20,
      // Spread range
      scale: 1.0,
      // Controls intensity **
      bias: 0.05
    }, ao));
    const bloomEffect = new BloomEffect(_extends({
      opacity: 1,
      blendFunction: BlendFunction.SCREEN,
      kernelSize: KernelSize.VERY_LARGE,
      luminanceThreshold: 0.9,
      luminanceSmoothing: 0.07,
      height: 600
    }, bloom));
    bloomEffect.blendMode.opacity.value = bloomOpacity;
    let effectsArray = [];
    if (effects) effectsArray = effects([smaaEffect, ssaoEffect, bloomEffect]);else {
      if (smaa) effectsArray.push(smaaEffect);
      if (ao) effectsArray.push(ssaoEffect);
      if (bloom) effectsArray.push(bloomEffect);
    }
    const effectPass = new EffectPass(camera, ...effectsArray);
    effectPass.renderToScreen = true;
    composer.addPass(normalPass);
    composer.addPass(effectPass);
    return composer;
  }, [camera, gl, scene, smaa, ao, bloom, edgeDetection, bloomOpacity]);
  useEffect(() => void composer.setSize(size.width, size.height), [composer, size]);
  return useFrame((_, delta) => composer.render(delta), 1);
}

extend({
  TextMeshImpl: TextMesh
});
const Text = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    anchorX = 'center',
    anchorY = 'middle',
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["anchorX", "anchorY", "children"]);

  const textRef = useRef();
  const [baseMtl, setBaseMtl] = useState();
  const [nodes, text] = useMemo(() => {
    let n = [];
    let t = '';
    Children.forEach(children, child => {
      if (typeof child === 'string') t += child;else if (child && typeof child === 'object' && child.props.attach === 'material') {
        // Instantiate the base material and grab a reference to it, but don't assign any
        // props, and assign it as the `material`, which Troika will replace behind the scenes.
        n.push( /*#__PURE__*/createElement(child.type, {
          ref: setBaseMtl,
          attach: 'material'
        })); // Once the base material has been assigned, grab the resulting upgraded material,
        // and apply the original material props to that.

        if (baseMtl) {
          n.push( /*#__PURE__*/React.createElement("primitive", _extends({
            object: textRef.current.material
          }, child.props, {
            attach: null
          })));
        }
      } else n.push(child);
    });
    return [n, t];
  }, [children, baseMtl]);
  useLayoutEffect(() => void textRef.current.sync());
  return /*#__PURE__*/React.createElement("textMeshImpl", _extends({
    ref: mergeRefs([textRef, ref]),
    text: text,
    anchorX: anchorX,
    anchorY: anchorY
  }, props), nodes);
});

const v1 = new Vector3();
const v2 = new Vector3();
const v3 = new Vector3();

function calculatePosition(el, camera, size) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}

function isObjectBehindCamera(el, camera) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}

function objectScale(el, camera) {
  if (camera instanceof PerspectiveCamera$1) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    return 1 / (2 * Math.tan(vFOV / 2) * dist);
  }

  if (camera instanceof OrthographicCamera$1) return camera.zoom;
  return 1;
}

function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof PerspectiveCamera$1 || camera instanceof OrthographicCamera$1) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }

  return undefined;
}

const HTML = /*#__PURE__*/React.forwardRef((_ref, ref) => {
  var _portal$current;

  let {
    children,
    eps = 0.001,
    style,
    className,
    prepend,
    center,
    fullscreen,
    portal,
    scaleFactor,
    zIndexRange = [16777271, 0]
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "eps", "style", "className", "prepend", "center", "fullscreen", "portal", "scaleFactor", "zIndexRange"]);

  const {
    gl,
    scene,
    camera,
    size
  } = useThree();
  const [el] = useState(() => document.createElement('div'));
  const group = useRef(null);
  const old = useRef([0, 0]);
  const target = (_portal$current = portal == null ? void 0 : portal.current) != null ? _portal$current : gl.domElement.parentNode;
  useEffect(() => {
    if (group.current) {
      scene.updateMatrixWorld();
      const vec = calculatePosition(group.current, camera, size);
      el.style.cssText = "position:absolute;top:0;left:0;transform:translate3d(" + vec[0] + "px," + vec[1] + "px,0);transform-origin:0 0;";

      if (target) {
        if (prepend) target.prepend(el);else target.appendChild(el);
      }

      return () => {
        if (target) target.removeChild(el);
        ReactDOM.unmountComponentAtNode(el);
      };
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [target]);
  const styles = useMemo(() => _extends({
    position: 'absolute',
    transform: center ? 'translate3d(-50%,-50%,0)' : 'none'
  }, fullscreen && {
    top: -size.height / 2,
    left: -size.width / 2,
    width: size.width,
    height: size.height
  }, style), [style, center, fullscreen, size]);
  useEffect(() => void ReactDOM.render( /*#__PURE__*/React.createElement("div", {
    ref: ref,
    style: styles,
    className: className,
    children: children
  }), el));
  useFrame(() => {
    if (group.current) {
      const vec = calculatePosition(group.current, camera, size);

      if (Math.abs(old.current[0] - vec[0]) > eps || Math.abs(old.current[1] - vec[1]) > eps) {
        el.style.display = !isObjectBehindCamera(group.current, camera) ? 'block' : 'none';
        const scale = scaleFactor === undefined ? 1 : objectScale(group.current, camera) * scaleFactor;
        el.style.transform = "translate3d(" + vec[0] + "px," + vec[1] + "px,0) scale(" + scale + ")";
        el.style.zIndex = "" + objectZIndex(group.current, camera, zIndexRange);
      }

      old.current = vec;
    }
  });
  return /*#__PURE__*/React.createElement("group", _extends({}, props, {
    ref: group
  }));
});

const Shadow = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    fog = false,
    colorStop = 0.0,
    color = 'black',
    opacity = 0.5
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["fog", "colorStop", "color", "opacity"]);

  const canvas = useMemo(() => {
    let canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    let context = canvas.getContext('2d');
    let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
    gradient.addColorStop(colorStop, new Color(color).getStyle());
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
    return canvas;
  }, [color, stop]);
  return /*#__PURE__*/React.createElement("mesh", _extends({
    ref: ref
  }, props), /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [1, 1]
  }), /*#__PURE__*/React.createElement("meshBasicMaterial", {
    attach: "material",
    transparent: true,
    opacity: opacity,
    fog: fog
  }, /*#__PURE__*/React.createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

function Stats({
  showPanel = 0,
  className
}) {
  const [stats] = useState(() => new StatsImpl());
  useEffect(() => {
    stats.showPanel(showPanel);
    document.body.appendChild(stats.dom);
    if (className) stats.dom.classList.add(className);
    return () => document.body.removeChild(stats.dom);
  }, []);
  return useFrame(state => {
    stats.begin();
    state.gl.render(state.scene, state.camera);
    stats.end();
  }, 1);
}

function WobbleMaterialImpl(parameters) {
  MeshStandardMaterial.call(this);
  this.setValues(parameters);
  this._time = {
    value: 0
  };
  this._factor = {
    value: 1
  };

  this.onBeforeCompile = shader => {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = 'uniform float time; uniform float factor;\n' + shader.vertexShader;
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;");
  };

  Object.defineProperty(this, 'time', {
    get: () => this._time,
    set: val => this._time.value = val
  });
  Object.defineProperty(this, 'factor', {
    get: () => this._factor,
    set: val => this._factor.value = val
  });
}

WobbleMaterialImpl.prototype = Object.create(MeshStandardMaterial.prototype);
WobbleMaterialImpl.prototype.constructor = MeshStandardMaterial;
WobbleMaterialImpl.prototype.isMeshStandardMaterial = true;
extend({
  WobbleMaterialImpl
});
const MeshWobbleMaterial = /*#__PURE__*/React.forwardRef((_ref, ref) => {
  let {
    speed = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  const material = useRef();
  useFrame(state => material.current && (material.current.time = state.clock.getElapsedTime() * speed));
  return /*#__PURE__*/React.createElement("wobbleMaterialImpl", _extends({
    ref: mergeRefs([ref, material]),
    attach: "material"
  }, props));
});

extend({
  SkyImpl: Sky$1
});
const Sky = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    distance = 450000,
    sunPosition = [0, 1, 0]
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["distance", "sunPosition"]);

  const scale = useMemo(() => new Vector3().setScalar(distance), [distance]);
  return /*#__PURE__*/React.createElement("skyImpl", _extends({
    ref: ref,
    "material-uniforms-sunPosition-value": sunPosition,
    scale: scale
  }, props));
});

extend({
  Line2,
  LineGeometry,
  LineMaterial
});
const Line = /*#__PURE__*/React.forwardRef(function Line(_ref, ref) {
  let {
    points,
    color = 'black',
    vertexColors
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["points", "color", "vertexColors"]);

  const lineRef = useRef();
  const geomRef = useRef();
  const resolution = useMemo(() => new Vector2(512, 512), []);
  useEffect(() => {
    if (!geomRef.current || !lineRef.current) return;
    geomRef.current.setPositions(points.flat());
    if (vertexColors) geomRef.current.setColors(vertexColors.flat());
    lineRef.current.computeLineDistances();
  }, [points, vertexColors]);
  return /*#__PURE__*/React.createElement("line2", _extends({
    ref: mergeRefs([lineRef, ref])
  }, rest), /*#__PURE__*/React.createElement("lineGeometry", {
    attach: "geometry",
    ref: geomRef
  }), /*#__PURE__*/React.createElement("lineMaterial", _extends({
    attach: "material",
    color: color,
    vertexColors: Boolean(vertexColors),
    resolution: resolution
  }, rest)));
});

class StarfieldMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0.0
        },
        fade: {
          value: 1.0
        }
      },
      vertexShader: "uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",
      fragmentShader: "uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n      }"
    });
  }

}

extend({
  StarfieldMaterial
});

const genStar = r => {
  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};

const Stars = /*#__PURE__*/forwardRef(({
  radius = 100,
  depth = 50,
  count = 5000,
  saturation = 0,
  factor = 4,
  fade = false
}, ref) => {
  const material = useRef();
  const [position, color, size] = useMemo(() => {
    const positions = [];
    const colors = [];
    const sizes = Array.from({
      length: count
    }, () => (0.5 + 0.5 * Math.random()) * factor);
    const color = new Color();
    let r = radius + depth;
    const increment = depth / count;

    for (var i = 0; i < count; i++) {
      r -= increment * Math.random();
      positions.push(...genStar(r).toArray());
      color.setHSL(i / count, saturation, 0.9);
      colors.push(color.r, color.g, color.b);
    }

    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];
  }, []);
  useFrame(state => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime()));
  return /*#__PURE__*/React.createElement("points", {
    ref: ref
  }, /*#__PURE__*/React.createElement("bufferGeometry", {
    attach: "geometry"
  }, /*#__PURE__*/React.createElement("bufferAttribute", {
    attachObject: ['attributes', 'position'],
    args: [position, 3]
  }), /*#__PURE__*/React.createElement("bufferAttribute", {
    attachObject: ['attributes', 'color'],
    args: [color, 3]
  }), /*#__PURE__*/React.createElement("bufferAttribute", {
    attachObject: ['attributes', 'size'],
    args: [size, 1]
  })), /*#__PURE__*/React.createElement("starfieldMaterial", {
    ref: material,
    attach: "material",
    blending: AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

function draco(url = '/draco-gltf/') {
  return loader => {
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(url);
    loader.setDRACOLoader(dracoLoader);
  };
}

const pcss = ({
  frustrum = 3.75,
  size = 0.005,
  near = 9.5,
  samples = 17,
  rings = 11
} = {}) => "#define LIGHT_WORLD_SIZE " + size + "\n#define LIGHT_FRUSTUM_WIDTH " + frustrum + "\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE " + near + "\n\n#define NUM_SAMPLES " + samples + "\n#define NUM_RINGS " + rings + "\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\tfloat angle = rand(randomSeed) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\tfor (int i = 0; i < NUM_SAMPLES; i++) {\n\t\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif (shadowMapDepth < zReceiver) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers++;\n\t\t}\n\t}\n\tif (numBlockers == 0) return -1.0;\n\treturn blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\tinitPoissonSamples(uv);\n\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\tif (avgBlockerDepth == -1.0) return 1.0;\n\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}";

const softShadows = props => {
  let shader = ShaderChunk.shadowmap_pars_fragment;
  shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\n' + pcss(_extends({}, props)));
  shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )');
  ShaderChunk.shadowmap_pars_fragment = shader;
};

let _inverseMatrix = new Matrix4();

let _ray = new Ray();

let _sphere = new Sphere$1();

let _vA = new Vector3();

function meshBounds(raycaster, intersects) {
  let geometry = this.geometry;
  let material = this.material;
  let matrixWorld = this.matrixWorld;
  if (material === undefined) return; // Checking boundingSphere distance to ray

  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

  _sphere.copy(geometry.boundingSphere);

  _sphere.applyMatrix4(matrixWorld);

  if (raycaster.ray.intersectsSphere(_sphere) === false) return;

  _inverseMatrix.getInverse(matrixWorld);

  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;
  intersects.push({
    distance: _vA.distanceTo(raycaster.ray.origin),
    point: _vA.clone(),
    object: this
  });
}

function useCamera(camera, props) {
  const {
    mouse
  } = useThree();
  const [raycast] = useState(() => {
    let raycaster = new Raycaster();
    if (props) applyProps(raycaster, props, {});
    return function (_, intersects) {
      raycaster.setFromCamera(mouse, camera instanceof Camera ? camera : camera.current);
      const rc = this.constructor.prototype.raycast.bind(this);
      if (rc) rc(raycaster, intersects);
    };
  });
  return raycast;
}

function useHelper(object3D, proto, ...args) {
  const helper = React.useRef();
  const {
    scene
  } = useThree();
  useEffect(() => {
    if (proto && object3D.current) {
      helper.current = new proto(object3D.current, ...args);

      if (helper.current) {
        scene.add(helper.current);
      }
    }

    return () => {
      if (helper.current) {
        scene.remove(helper.current);
      }
    };
  }, [scene, proto, object3D, args]);
  useFrame(() => {
    if (helper.current) {
      helper.current.update();
    }
  });
  return helper;
}

function useAspect(type, width, height, factor = 1) {
  const {
    viewport: v,
    aspect
  } = useThree();
  const adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);
  const adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

function create(type) {
  const El = type + 'BufferGeometry';
  return /*#__PURE__*/forwardRef((_ref, ref) => {
    let {
      args,
      children
    } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, ["args", "children"]);

    return /*#__PURE__*/React.createElement("mesh", _extends({
      ref: ref
    }, props), /*#__PURE__*/React.createElement(El, {
      attach: "geometry",
      args: args
    }), children);
  });
}

const Box = create('box');
const Circle = create('circle');
const Cone = create('cone');
const Cylinder = create('cylinder');
const Sphere = create('sphere');
const Plane = create('plane');
const Tube = create('tube');
const Torus = create('torus');
const TorusKnot = create('torusKnot');
const Tetrahedron = create('tetrahedron');
const Ring = create('ring');
const Polyhedron = create('polyhedron');
const Icosahedron = create('icosahedron');
const Octahedron = create('octahedron');
const Dodecahedron = create('dodecahedron');
const Extrude = create('extrude');
const Lathe = create('lathe');
const Parametric = create('parametric');

export { Box, Circle, Cone, Cylinder, Detailed, Dodecahedron, Extrude, HTML, Icosahedron, Lathe, Line, MapControls, MeshWobbleMaterial, Octahedron, OrbitControls, OrthographicCamera, Parametric, PerspectiveCamera, Plane, Polyhedron, PositionalAudio, Ring, Shadow, Sky, Sphere, StandardEffects, Stars, Stats, Tetrahedron, Text, Torus, TorusKnot, TrackballControls, TransformControls, Tube, draco, meshBounds, softShadows, useAspect, useCamera, useHelper };
